module Rulers
	(* project	= "BlackBox"
	   organization	= "www.oberon.ch"
	   contributors	= "Oberon microsystems"
	   version	= "System/Rsrc/About"
	   copyright	= "System/Rsrc/About"
	   license	= "Docu/BB-License"
	   changes	= "##=>
	   
	   - 20080904, et, Precondition check 21 in SetDir corrected
	   - 20170620, center #163, adding decimal tabs to TextRulers
	   - 20170905, center #173, adding new modifiers to Controllers
	   ##<="
	   issues	= "##=>
	   
	   - ...
	   ##<=" *)
	
	
	
	
	// re-check alien attributes: consider projection semantics
	
	import 
		System.Kernel, System.Strings, System.Services, System.Fonts, System.Ports, System.Stores, 
		System.Models, System.Views, System.Controllers, System.Properties, System.Dialog, 
		TextModels := Models
	
	const 
		// Attributes.valid, Prop.known/valid// Mark.kind
		first* = 0
		left* = 1
		right* = 2
		lead* = 3
		asc* = 4
		dsc* = 5
		grid* = 6
		opts* = 7
		tabs* = 8
		// additional values for icons held by Mark.kind
		invalid = -1
		firstIcon = 10
		lastIcon = 25
		rightToggle = 10
		gridDec = 12
		gridVal = 13
		gridInc = 14
		leftFlush = 16
		centered = 17
		rightFlush = 18
		justified = 19
		leadDec = 21
		leadVal = 22
		leadInc = 23
		pageBrk = 25
		
		modeIcons = {leftFlush..justified}
		validIcons = {rightToggle, gridDec..gridInc, leftFlush..justified, leadDec..leadInc, pageBrk}
		fieldIcons = {gridVal, leadVal}
		
		// Attributes.opts
		leftAdjust* = 0
		rightAdjust* = 1
		// both: fully justified; none: centered
		noBreakInside* = 2
		pageBreak* = 3
		parJoin* = 4
		// pageBreak of this ruler overrides parJoin request of previous ruler
		rightFixed* = 5 // has fixed right border
		
		options = {leftAdjust..rightFixed} // options mask
		adjMask = {leftAdjust, rightAdjust}
		
		// Attributes.tabType[i]
		maxTabs* = 32
		centerTab* = 0
		rightTab* = 1
		// both: decimal Tab; none: leftTab
		barTab* = 2
		
		tabOptions = {centerTab..barTab} // mask for presently valid options
		
		mm = Ports.mm
		inch16 = Ports.inch div 16
		point = Ports.point
		tabBarHeight = 11 * point
		scaleHeight = 10 * point
		iconBarHeight = 14 * point
		rulerHeight = tabBarHeight + scaleHeight + iconBarHeight
		iconHeight = 10 * point
		iconWidth = 12 * point
		iconGap = 2 * point
		iconPin = rulerHeight - (iconBarHeight - iconHeight) div 2
		
		rulerChangeKey = "#Text:RulerChange"
		
		minVersion = 0
		maxAttrVersion = 3
		maxStyleVersion = 0
		maxStdStyleVersion = 0
		maxRulerVersion = 0
		maxStdRulerVersion = 0
	
	
	type 
		Tab* = record 
				stop*: integer
				type_*: set 
			end 
		
		TabArray* = record  // should be POINTER TO ARRAY OF Tab -- but cannot protect
				len_*: integer
				tab*: array maxTabs of Tab 
			end 
		
		TabData = array maxTabs of wchar // radix character for decimal tabs
		
		Attributes* = pointer to (* extensible *) record (Stores.Store) 
				init-: boolean // immutable once init holds
				first-, left-, right-, lead-, asc-, dsc-, grid-: integer
				opts-: set
				tabs-: TabArray
				tabsData: TabData  // separated from TabArray for compatibility with 1.7
			end 
		
		AlienAttributes* = pointer to record (Attributes) 
				store-: Stores.Alien 
			end 
		
		Style* = pointer to (* abstract *) record (Models.Model) 
				attr-: Attributes 
			end 
		
		Ruler* = pointer to (* abstract *) record (Views.View) 
				style-: Style 
			end 
		
		
		Prop* = pointer to record (Properties.Property) 
				first*, left*, right*, lead*, asc*, dsc*, grid*: integer
				opts*: record val_*, mask*: set end 
				tabs*: TabArray
				tabsData: TabData 
			end 
		
		
		UpdateMsg* = record (Models.UpdateMsg) 
				// domaincast upon style update
				style*: Style
				oldAttr*: Attributes 
			end 
		
		
		Directory* = pointer to (* abstract *) record 
				attr-: Attributes 
			end 
		
		
		StdStyle = pointer to record (Style) end 
		
		StdRuler = pointer to record (Ruler) 
				sel: integer // sel # invalid => sel = kind of selected mark
				px, py: integer  // sel # invalid => px, py of selected mark
			end 
		
		StdDirectory = pointer to record (Directory) end 
		
		Mark = record 
				ruler: StdRuler
				l, r, t, b: integer
				px, py, px0, py0, x, y: integer
				kind, index: integer
				type_: set // valid if kind = tabs
				tabs: TabArray // if valid: tabs[index].type = type
				tabsData: TabData
				dirty: boolean 
			end 
		
		SetAttrOp = pointer to record (Stores.Operation) 
				style: Style
				attr: Attributes 
			end 
		
		NeutralizeMsg = record (Views.Message) end 
		
		TabDialogHook* = pointer to (* abstract *) record (Kernel.Hook) end 
	
	
	var 
		dir-, stdDir-: Directory
		defaultRadixChar*: wchar // for decimal tab
		tabDialogHook*: TabDialogHook // see TextCmds
		
		def: Attributes
		prop: Prop // recycled
		globRd: TextModels.Reader // cache for temp reader; beware of reentrance
		font: Fonts.Font
		
		marginGrid, minTabWidth, tabGrid: integer
	
	proc (hook: TabDialogHook) Open*(ruler: Ruler; tabIndex: integer)  end // new abstract
	proc (hook: TabDialogHook) Init*(ruler: Ruler; tabIndex: integer)  end // new abstract
	proc (hook: TabDialogHook) Refresh*(style: Style)  end // new abstract
	
	proc CopyTabs(in src: TabArray; in srcData: TabData; var dst: TabArray; var dstData: TabData) 
		// a TabArray is a 256 byte structure - copying of used parts is much faster than ":= all"
		var 
			i, n: integer
	begin 
		n := src.len_
		dst.len_ := n
		i := 0
		while i < n do 
			dst.tab[i] := src.tab[i]
			dstData[i] := srcData[i]
			inc(i) 
		end 
	end CopyTabs
	
	proc CopyTab(in src: TabArray; in srcData: TabData; srcIdx: integer
		var dst: TabArray; var dstData: TabData; dstIdx: integer) 
	begin 
		dst.tab[dstIdx] := src.tab[srcIdx]
		dstData[dstIdx] := srcData[srcIdx]
	end CopyTab
	
	proc InitTab(x: integer; var tabs: TabArray; var tabsData: TabData; tabIndex: integer) 
	begin 
		tabs.tab[tabIndex].stop := x
		tabs.tab[tabIndex].type_ := {}
		tabsData[tabIndex] := defaultRadixChar
	end InitTab
	
	// Attributes
	
	proc (a: Attributes) CopyFrom*(source: Stores.Store)  // extensible
	begin 
		with source: Attributes do 
			assert(~a.init, 20)
			assert(source.init, 21)
			a.init := true
			a.first := source.first
			a.left := source.left
			a.right := source.right
			a.lead := source.lead
			a.asc := source.asc
			a.dsc := source.dsc
			a.grid := source.grid
			a.opts := source.opts
			CopyTabs(source.tabs, source.tabsData, a.tabs, a.tabsData) 
		end 
	end CopyFrom
	
	proc HasTabsData(a: Attributes): boolean 
		var 
			i: integer
	begin 
		i := 0
		while (i < a.tabs.len_) 
			& ((a.tabs.tab[i].type_ * {centerTab, rightTab} # {centerTab, rightTab}) or (a.tabsData[i] = ".")) do 
			inc(i) 
		end 
		return i < a.tabs.len_
	end HasTabsData
	
	proc (a: Attributes) Externalize*(var wr: Stores.Writer)  // extensible
		// pre: a.init
		var 
			i: integer
			typedTabs, hasTabsData: boolean
	begin 
		assert(a.init, 20)
		a.Externalize^(wr)
		i := 0
		while (i < a.tabs.len_) & (a.tabs.tab[i].type_ = {}) do 
			inc(i) 
		end 
		typedTabs := i < a.tabs.len_
		hasTabsData := false
		if typedTabs then
			hasTabsData := HasTabsData(a) // use version 3 if there are decimal tabs with radix char # "."
			if hasTabsData then
				wr.WriteVersion(3) 
			else 
				wr.WriteVersion(2) 
			end  
		else 
			wr.WriteVersion(1)  // versions before 2 had only leftTabs
		end 
		wr.WriteInt(a.first)
		wr.WriteInt(a.left)
		wr.WriteInt(a.right)
		wr.WriteInt(a.lead)
		wr.WriteInt(a.asc)
		wr.WriteInt(a.dsc)
		wr.WriteInt(a.grid)
		wr.WriteSet(a.opts)
		wr.WriteXInt(a.tabs.len_)
		i := 0
		while i < a.tabs.len_ do 
			wr.WriteInt(a.tabs.tab[i].stop)
			inc(i) 
		end 
		if typedTabs then
			i := 0
			while i < a.tabs.len_ do 
				wr.WriteSet(a.tabs.tab[i].type_)
				inc(i) 
			end  
		end 
		if hasTabsData then
			for i:= 0 to a.tabs.len_ - 1 do 
				if (a.tabs.tab[i].type_ * {centerTab, rightTab} = {centerTab, rightTab}) then
					wr.WriteChar(a.tabsData[i]) 
				end  
			end  
		end 
	end Externalize
	
	proc (a: Attributes) Internalize*(var rd: Stores.Reader)  // extensible
		// pre: ~a.init
		// post: a.init
		var 
			thisVersion, i, n, stop, trash: integer
			trashSet: set
	begin 
		assert(~a.init, 20)
		a.init := true
		a.Internalize^(rd)
		if rd.cancelled then
			return  
		end 
		rd.ReadVersion(minVersion, maxAttrVersion, thisVersion)
		if rd.cancelled then
			return  
		end 
		rd.ReadInt(a.first)
		rd.ReadInt(a.left)
		rd.ReadInt(a.right)
		rd.ReadInt(a.lead)
		rd.ReadInt(a.asc)
		rd.ReadInt(a.dsc)
		rd.ReadInt(a.grid)
		rd.ReadSet(a.opts)
		rd.ReadXInt(n)
		a.tabs.len_ := min(n, maxTabs)
		i := 0
		while i < a.tabs.len_ do 
			rd.ReadInt(stop)
			InitTab(stop, a.tabs, a.tabsData, i)
			inc(i) 
		end 
		while i < n do 
			rd.ReadInt(trash)
			inc(i) 
		end 
		if thisVersion = 0 then // convert from v0 rightFixed to v1 ~rightFixed default
			incl(a.opts, rightFixed) 
		end 
		if thisVersion >= 2 then
			i := 0
			while i < a.tabs.len_ do 
				rd.ReadSet(a.tabs.tab[i].type_)
				inc(i) 
			end 
			while i < n do 
				rd.ReadSet(trashSet)
				inc(i) 
			end 
			for i:= 0 to a.tabs.len_ - 1 do 
				if (a.tabs.tab[i].type_ * {centerTab, rightTab} = {centerTab, rightTab}) then
					if thisVersion >= 3 then
						rd.ReadChar(a.tabsData[i]) 
					else 
						a.tabsData[i] := "." 
					end  
				end  
			end  
		end 
	end Internalize
	
	proc Set(p: Prop; opt: integer; var x: integer; min_, max_, new_: integer) 
	begin 
		if opt in p.valid then
			x := max(min_, min(max_, new_)) 
		end 
	end Set
	
	proc ModifyFromProp(a: Attributes; p: Properties.Property) 
		const 
			maxW = 10000 * mm
			maxH = 32767 * point
			mask = tabOptions
		var 
			i: integer
			type_: set
	begin 
		while p # nil do 
			with p: Prop do 
				Set(p, first, a.first, 0, maxW, p.first)
				Set(p, left, a.left, 0, maxW, p.left)
				Set(p, right, a.right, max(a.left, a.first), maxW, p.right)
				Set(p, lead, a.lead, 0, maxH, p.lead)
				Set(p, asc, a.asc, 0, maxH, p.asc)
				Set(p, dsc, a.dsc, 0, maxH - a.asc, p.dsc)
				Set(p, grid, a.grid, 1, maxH, p.grid)
				if opts in p.valid then
					a.opts := a.opts * (-p.opts.mask) + p.opts.val_ * p.opts.mask 
				end 
				if (tabs in p.valid) & (p.tabs.len_ >= 0) then
					if (p.tabs.len_ > 0) & (p.tabs.tab[0].stop >= 0) then
						i := 0
						a.tabs.len_ := min(p.tabs.len_, maxTabs)
						repeat 
							type_ := a.tabs.tab[i].type_ * (-mask) + p.tabs.tab[i].type_ * mask
							CopyTab(p.tabs, p.tabsData, i, a.tabs, a.tabsData, i)
							a.tabs.tab[i].type_ := type_
							inc(i) 
						until (i = a.tabs.len_) or (p.tabs.tab[i].stop < p.tabs.tab[i - 1].stop) 
						a.tabs.len_ := i 
					else 
						a.tabs.len_ := 0 
					end  
				end  
			else  
			end 
			p := p.next 
		end 
	end ModifyFromProp
	
	proc (a: Attributes) ModifyFromProp*(p: Properties.Property)  // new extensible
	begin 
		ModifyFromProp(a, p)
	end ModifyFromProp
	
	proc (a: Attributes) InitFromProp*(p: Properties.Property)  // new extensible
	// pre: ~a.init
	// post: (a.init, p # NIL & x IN p.valid) => x set in a, else x defaults in a
	begin 
		assert(~a.init, 20)
		a.init := true
		a.first := def.first
		a.left := def.left
		a.right := def.right
		a.lead := def.lead
		a.asc := def.asc
		a.dsc := def.dsc
		a.grid := def.grid
		a.opts := def.opts
		CopyTabs(def.tabs, def.tabsData, a.tabs, a.tabsData)
		ModifyFromProp(a, p)
	end InitFromProp
	
	proc (a: Attributes) Equals*(b: Attributes): boolean  // new extensible
		// pre: a.init, b.init
		var 
			i: integer
	begin 
		assert(a.init, 20)
		assert(b.init, 21)
		if a # b then
			i := 0
			while (i < a.tabs.len_) 
				& (a.tabs.tab[i].stop = b.tabs.tab[i].stop) 
				& (a.tabs.tab[i].type_ = b.tabs.tab[i].type_) do 
				inc(i) 
			end 
			return (Services.SameType(a, b)) 
				& (a.first = b.first) & (a.left = b.left) & (a.right = b.right) 
				& (a.lead = b.lead) & (a.asc = b.asc) & (a.dsc = b.dsc) & (a.grid = b.grid) 
				& (a.opts = b.opts) & (a.tabs.len_ = b.tabs.len_) & (i = a.tabs.len_) 
		else 
			return true 
		end 
	end Equals
	
	proc (a: Attributes) Prop*(): Properties.Property  // new extensible
		// pre: a.init
		// post: x attr in a => x IN p.valid, m set to value of attr in a
		var 
			p: Prop
	begin 
		assert(a.init, 20)
		new(p)
		p.known := {first..tabs}
		p.valid := p.known
		p.first := a.first
		p.left := a.left
		p.right := a.right
		p.lead := a.lead
		p.asc := a.asc
		p.dsc := a.dsc
		p.grid := a.grid
		p.opts.val_ := a.opts
		p.opts.mask := options
		CopyTabs(a.tabs, a.tabsData, p.tabs, p.tabsData)
		return p
	end Prop
	
	
	proc ReadAttr*(var rd: Stores.Reader; var a: Attributes) 
		var 
			st: Stores.Store
			alien: AlienAttributes
	begin 
		rd.ReadStore(st)
		assert(st # nil, 100)
		if st is Stores.Alien then
			new(alien)
			alien.store := st(Stores.Alien)
			Stores.Join(alien, alien.store)
			alien.InitFromProp(nil)
			a := alien 
		else 
			a := st(Attributes) 
		end 
	end ReadAttr
	
	proc WriteAttr*(var wr: Stores.Writer; a: Attributes) 
	begin 
		assert(a # nil, 20)
		assert(a.init, 21)
		with a: AlienAttributes do 
			wr.WriteStore(a.store) 
		else 
			wr.WriteStore(a) 
		end 
	end WriteAttr
	
	proc ModifiedAttr*(a: Attributes; p: Properties.Property): Attributes 
		// pre: a.init
		// post: x IN p.valid => x in new attr set to value in p, else set to value in a
		var 
			h: Attributes
	begin 
		assert(a.init, 20)
		h := Stores.CopyOf(a)(Attributes)
		h.ModifyFromProp(p)
		return h
	end ModifiedAttr
	
	
	// AlienAttributes
	
	proc (a: AlienAttributes) Externalize*(var wr: Stores.Writer) 
	begin 
		halt(100)
	end Externalize
	
	proc (a: AlienAttributes) Internalize*(var rd: Stores.Reader) 
	begin 
		halt(100)
	end Internalize
	
	proc (a: AlienAttributes) InitFromProp*(p: Properties.Property) 
	begin 
		a.InitFromProp^(nil)
	end InitFromProp
	
	proc (a: AlienAttributes) ModifyFromProp*(p: Properties.Property) 
	begin 
		// a.InitFromProp^(NIL)
		a.InitFromProp(nil)
	end ModifyFromProp
	
	
	// Style
	
	(* PROCEDURE (s: Style) PropagateDomain-, EXTENSIBLE;
	   VAR dom: Stores.Domain;
	   BEGIN
	   ASSERT(s.attr # NIL, 20);
	   dom := s.attr.Domain();
	   IF (dom # NIL) & (dom # s.Domain()) THEN s.attr := Stores.CopyOf(s.attr)(Attributes) END;
	   Stores.InitDomain(s.attr, s.Domain())
	   END PropagateDomain; *)
	
	
	
	proc (s: Style) Externalize*(var wr: Stores.Writer)  // extensible
	begin 
		s.Externalize^(wr)
		wr.WriteVersion(maxStyleVersion)
		WriteAttr(wr, s.attr)
	end Externalize
	
	proc (s: Style) Internalize*(var rd: Stores.Reader)  // extensible
		var 
			thisVersion: integer
	begin 
		s.Internalize^(rd)
		if rd.cancelled then
			return  
		end 
		rd.ReadVersion(minVersion, maxStyleVersion, thisVersion)
		if rd.cancelled then
			return  
		end 
		ReadAttr(rd, s.attr)
		Stores.Join(s, s.attr)
	end Internalize
	
	proc (s: Style) SetAttr*(attr: Attributes)  // new extensible
	// pre: attr.init
	// post: s.attr = attr OR s.attr.Equals(attr)
	begin 
		assert(attr.init, 20)
		DoSetAttrOp(s, attr)
	end SetAttr
	
	proc (s: Style) CopyFrom*(source: Stores.Store)  // extensible
	begin 
		with source: Style do 
			assert(source.attr # nil, 21)
			s.SetAttr(Stores.CopyOf(source.attr)(Attributes)) 
		// bkwd-comp hack to avoid link
		// copy would not be necessary if Attributes were immutable (and assigned to an Immutable Domain)
		end 
	end CopyFrom
	
	(* PROCEDURE (s: Style) InitFrom- (source: Models.Model), EXTENSIBLE;
	   BEGIN
	   WITH source: Style DO
	   ASSERT(source.attr # NIL, 21);
	   s.SetAttr(Stores.CopyOf(source.attr)(Attributes))
	   (* bkwd-comp hack to avoid link *)
	   END
	   END InitFrom; *)
	
	
	
	// Directory
	
	proc (d: Directory) SetAttr*(attr: Attributes)  // new extensible
		// pre: attr.init
		(* post: d.attr = ModifiedAttr(attr, p)
		   [ p.valid = {opts, tabs}, p.tabs.len = 0, p.opts.mask = {noBreakInside.. parJoin}, p.opts.val = {} ] *)
		
		var 
			p: Prop
	begin 
		assert(attr.init, 20)
		if attr.tabs.len_ > 0 then
			new(p)
			p.valid := {opts, tabs}
			p.opts.mask := {noBreakInside, pageBreak, parJoin}
			p.opts.val_ := {}
			p.tabs.len_ := 0
			attr := ModifiedAttr(attr, p) 
		end 
		d.attr := attr
	end SetAttr
	
	proc (d: Directory) NewStyle*(attr: Attributes): Style  end // new abstract
	proc (d: Directory) New*(style: Style): Ruler  end // new abstract
	
	proc (d: Directory) NewFromProp*(p: Prop): Ruler  // new extensible
	begin 
		return d.New(d.NewStyle(ModifiedAttr(d.attr, p)))
	end NewFromProp
	
	
	proc Deposit*
	begin 
		Views.Deposit(dir.New(nil))
	end Deposit
	
	
	// Ruler
	
	proc (r: Ruler) Externalize*(var wr: Stores.Writer)  // extensible
	begin 
		assert(r.style # nil, 20)
		r.Externalize^(wr)
		wr.WriteVersion(maxRulerVersion)
		wr.WriteStore(r.style)
	end Externalize
	
	proc (r: Ruler) InitStyle*(s: Style)  // new
	// pre: r.style = NIL, s # NIL, style.attr # NIL
	// post: r.style = s
	begin 
		assert((r.style = nil) or (r.style = s), 20)
		assert(s # nil, 21)
		assert(s.attr # nil, 22)
		r.style := s
		Stores.Join(r, s)
	end InitStyle
	
	
	proc (r: Ruler) Internalize*(var rd: Stores.Reader)  // extensible
		var 
			st: Stores.Store
			thisVersion: integer
	begin 
		r.Internalize^(rd)
		if rd.cancelled then
			return  
		end 
		rd.ReadVersion(minVersion, maxRulerVersion, thisVersion)
		if rd.cancelled then
			return  
		end 
		rd.ReadStore(st)
		if st is Stores.Alien then
			rd.TurnIntoAlien(Stores.alienComponent)
			return  
		end 
		r.InitStyle(st(Style))
	end Internalize
	
	(* PROCEDURE (r: Ruler) InitModel* (m: Models.Model), EXTENSIBLE;
	   (** pre: r.style = NIL, m # NIL, style.attr # NIL, m IS Style **)
	   (** post: r.style = m **)
	   BEGIN
	   WITH m: Style DO
	   ASSERT((r.style = NIL) OR (r.style = m), 20);
	   ASSERT(m # NIL, 21); ASSERT(m.attr # NIL, 22);
	   r.style := m
	   ELSE HALT(23)
	   END
	   END InitModel; *)
	
	
	
	(* PROCEDURE (r: Ruler) PropagateDomain-, EXTENSIBLE;
	   BEGIN
	   ASSERT(r.style # NIL, 20);
	   Stores.InitDomain(r.style, r.Domain())
	   END PropagateDomain; *)
	
	
	
	proc CopyOf*(r: Ruler; shallow: boolean): Ruler 
		var 
			v: Views.View
	begin 
		assert(r # nil, 20)
		v := Views.CopyOf(r, shallow)
		return v(Ruler)
	end CopyOf
	
	
	// Prop
	
	proc (p: Prop) IntersectWith*(q: Properties.Property; var equal: boolean) 
		var 
			valid: set
			i: integer
			c, m: set
			eq: boolean
	begin 
		with q: Prop do 
			valid := p.valid * q.valid
			equal := true
			i := 0
			while (i < p.tabs.len_) 
				& (p.tabs.tab[i].stop = q.tabs.tab[i].stop) 
				& (p.tabs.tab[i].type_ = q.tabs.tab[i].type_) 
			do 
				inc(i) 
			end 
			if p.first # q.first then
				excl(valid, first) 
			end 
			if p.left # q.left then
				excl(valid, left) 
			end 
			if p.right # q.right then
				excl(valid, right) 
			end 
			if p.lead # q.lead then
				excl(valid, lead) 
			end 
			if p.asc # q.asc then
				excl(valid, asc) 
			end 
			if p.dsc # q.dsc then
				excl(valid, dsc) 
			end 
			if p.grid # q.grid then
				excl(valid, grid) 
			end 
			Properties.IntersectSelections(p.opts.val_, p.opts.mask, q.opts.val_, q.opts.mask, c, m, eq)
			if m = {} then
				excl(valid, opts) 
			elsif (opts in valid) & ~eq then 
				p.opts.mask := m
				equal := false 
			end 
			if (p.tabs.len_ # q.tabs.len_) or (q.tabs.len_ # i) then
				excl(valid, tabs) 
			end 
			if p.valid # valid then
				p.valid := valid
				equal := false 
			end  
		end 
	end IntersectWith
	
	
	// ruler construction
	
	// property-based facade procedures
	(* PROCEDURE SetFirst* (p: Prop; x: INTEGER);
	   BEGIN
	   ASSERT(p # NIL, 20);
	   INCL(p.valid, first); p.first := x
	   END SetFirst;
	   
	   PROCEDURE SetLeft* (p: Prop; x: INTEGER);
	   BEGIN
	   ASSERT(p # NIL, 20);
	   INCL(p.valid, left); p.left := x
	   END SetLeft;
	   
	   PROCEDURE SetRight* (p: Prop; x: INTEGER);
	   BEGIN
	   ASSERT(p # NIL, 20);
	   INCL(p.valid, right); p.right := x
	   END SetRight;
	   
	   PROCEDURE SetFixedRight* (p: Prop; x: INTEGER);
	   BEGIN
	   ASSERT(p # NIL, 20);
	   INCL(p.valid, right); p.right := x;
	   INCL(p.valid, opts); INCL(p.opts.mask, rightFixed); INCL(p.opts.val, rightFixed)
	   END SetFixedRight;
	   
	   
	   PROCEDURE SetLead* (p: Prop; h: INTEGER);
	   BEGIN
	   ASSERT(p # NIL, 20);
	   INCL(p.valid, lead); p.lead := h
	   END SetLead;
	   
	   PROCEDURE SetAsc* (p: Prop; h: INTEGER);
	   BEGIN
	   ASSERT(p # NIL, 20);
	   INCL(p.valid, asc); p.asc := h
	   END SetAsc;
	   
	   PROCEDURE SetDsc* (p: Prop; h: INTEGER);
	   BEGIN
	   ASSERT(p # NIL, 20);
	   INCL(p.valid, dsc); p.dsc := h
	   END SetDsc;
	   
	   PROCEDURE SetGrid* (p: Prop; h: INTEGER);
	   BEGIN
	   ASSERT(p # NIL, 20);
	   INCL(p.valid, grid); p.grid := h
	   END SetGrid;
	   
	   
	   PROCEDURE SetLeftFlush* (p: Prop);
	   BEGIN
	   ASSERT(p # NIL, 20);
	   INCL(p.valid, opts);
	   p.opts.mask := p.opts.mask + {leftAdjust, rightAdjust};
	   p.opts.val := p.opts.val + {leftAdjust} - {rightAdjust}
	   END SetLeftFlush;
	   
	   PROCEDURE SetRightFlush* (p: Prop);
	   BEGIN
	   ASSERT(p # NIL, 20);
	   INCL(p.valid, opts);
	   p.opts.mask := p.opts.mask + {leftAdjust, rightAdjust};
	   p.opts.val := p.opts.val - {leftAdjust} + {rightAdjust}
	   END SetRightFlush;
	   
	   PROCEDURE SetCentered* (p: Prop);
	   BEGIN
	   ASSERT(p # NIL, 20);
	   INCL(p.valid, opts);
	   p.opts.mask := p.opts.mask + {leftAdjust, rightAdjust};
	   p.opts.val := p.opts.val - {leftAdjust, rightAdjust}
	   END SetCentered;
	   
	   PROCEDURE SetJustified* (p: Prop);
	   BEGIN
	   ASSERT(p # NIL, 20);
	   INCL(p.valid, opts);
	   p.opts.mask := p.opts.mask + {leftAdjust, rightAdjust};
	   p.opts.val := p.opts.val + {leftAdjust, rightAdjust}
	   END SetJustified;
	   
	   
	   PROCEDURE SetNoBreakInside* (p: Prop);
	   BEGIN
	   ASSERT(p # NIL, 20);
	   INCL(p.valid, opts);
	   INCL(p.opts.mask, noBreakInside); INCL(p.opts.val, noBreakInside)
	   END SetNoBreakInside;
	   
	   PROCEDURE SetPageBreak* (p: Prop);
	   BEGIN
	   ASSERT(p # NIL, 20);
	   INCL(p.valid, opts);
	   INCL(p.opts.mask, pageBreak); INCL(p.opts.val, pageBreak)
	   END SetPageBreak;
	   
	   PROCEDURE SetParJoin* (p: Prop);
	   BEGIN
	   ASSERT(p # NIL, 20);
	   INCL(p.valid, opts);
	   INCL(p.opts.mask, parJoin); INCL(p.opts.val, parJoin)
	   END SetParJoin;
	   
	   
	   PROCEDURE AddTab* (p: Prop; x: INTEGER);
	   VAR i: INTEGER;
	   BEGIN
	   ASSERT(p # NIL, 20); i := p.tabs.len; ASSERT(i > 0, 21);
	   ASSERT((i = 0) OR (p.tabs.tab[i - 1].stop < x), 22);
	   INCL(p.valid, tabs);
	   p.tabs.tab[i].stop := x; p.tabs.tab[i].type := {};
	   p.tabs.len := i + 1
	   END AddTab;
	   
	   PROCEDURE MakeCenterTab* (p: Prop);
	   VAR i: INTEGER;
	   BEGIN
	   ASSERT(p # NIL, 20); i := p.tabs.len; ASSERT(i > 0, 21);
	   p.tabs.tab[i - 1].type := p.tabs.tab[i - 1].type + {centerTab} - {rightTab}
	   END MakeCenterTab;
	   
	   PROCEDURE MakeRightTab* (p: Prop);
	   VAR i: INTEGER;
	   BEGIN
	   ASSERT(p # NIL, 20); i := p.tabs.len; ASSERT(i > 0, 21);
	   p.tabs.tab[i - 1].type := p.tabs.tab[i - 1].type - {centerTab} + {rightTab}
	   END MakeRightTab;
	   
	   PROCEDURE MakeBarTab* (p: Prop);
	   VAR i: INTEGER;
	   BEGIN
	   ASSERT(p # NIL, 20); i := p.tabs.len; ASSERT(i > 0, 21);
	   p.tabs.tab[i - 1].type := p.tabs.tab[i - 1].type + {barTab}
	   END MakeBarTab; *)
	
	
	
	proc SetFirst*(r: Ruler; x: integer) 
	begin 
		assert(r.style # nil, 20)
		prop.valid := {first}
		prop.first := x
		r.style.SetAttr(ModifiedAttr(r.style.attr, prop))
	end SetFirst
	
	proc SetLeft*(r: Ruler; x: integer) 
	begin 
		assert(r.style # nil, 20)
		prop.valid := {left}
		prop.left := x
		r.style.SetAttr(ModifiedAttr(r.style.attr, prop))
	end SetLeft
	
	proc SetRight*(r: Ruler; x: integer) 
	begin 
		assert(r.style # nil, 20)
		prop.valid := {right}
		prop.right := x
		prop.opts.mask := {rightFixed}
		prop.opts.val_ := {}
		r.style.SetAttr(ModifiedAttr(r.style.attr, prop))
	end SetRight
	
	proc SetFixedRight*(r: Ruler; x: integer) 
	begin 
		assert(r.style # nil, 20)
		prop.valid := {right, opts}
		prop.right := x
		prop.opts.mask := {rightFixed}
		prop.opts.val_ := {rightFixed}
		r.style.SetAttr(ModifiedAttr(r.style.attr, prop))
	end SetFixedRight
	
	
	proc SetLead*(r: Ruler; h: integer) 
	begin 
		assert(r.style # nil, 20)
		prop.valid := {lead}
		prop.lead := h
		r.style.SetAttr(ModifiedAttr(r.style.attr, prop))
	end SetLead
	
	proc SetAsc*(r: Ruler; h: integer) 
	begin 
		assert(r.style # nil, 20)
		prop.valid := {asc}
		prop.asc := h
		r.style.SetAttr(ModifiedAttr(r.style.attr, prop))
	end SetAsc
	
	proc SetDsc*(r: Ruler; h: integer) 
	begin 
		assert(r.style # nil, 20)
		prop.valid := {dsc}
		prop.dsc := h
		r.style.SetAttr(ModifiedAttr(r.style.attr, prop))
	end SetDsc
	
	proc SetGrid*(r: Ruler; h: integer) 
	begin 
		assert(r.style # nil, 20)
		prop.valid := {grid}
		prop.grid := h
		r.style.SetAttr(ModifiedAttr(r.style.attr, prop))
	end SetGrid
	
	
	proc SetLeftFlush*(r: Ruler) 
	begin 
		assert(r.style # nil, 20)
		prop.valid := {opts}
		prop.opts.mask := {leftAdjust, rightAdjust}
		prop.opts.val_ := {leftAdjust}
		r.style.SetAttr(ModifiedAttr(r.style.attr, prop))
	end SetLeftFlush
	
	proc SetRightFlush*(r: Ruler) 
	begin 
		assert(r.style # nil, 20)
		prop.valid := {opts}
		prop.opts.mask := {leftAdjust, rightAdjust}
		prop.opts.val_ := {rightAdjust}
		r.style.SetAttr(ModifiedAttr(r.style.attr, prop))
	end SetRightFlush
	
	proc SetCentered*(r: Ruler) 
	begin 
		assert(r.style # nil, 20)
		prop.valid := {opts}
		prop.opts.mask := {leftAdjust, rightAdjust}
		prop.opts.val_ := {}
		r.style.SetAttr(ModifiedAttr(r.style.attr, prop))
	end SetCentered
	
	proc SetJustified*(r: Ruler) 
	begin 
		assert(r.style # nil, 20)
		prop.valid := {opts}
		prop.opts.mask := {leftAdjust, rightAdjust}
		prop.opts.val_ := {leftAdjust, rightAdjust}
		r.style.SetAttr(ModifiedAttr(r.style.attr, prop))
	end SetJustified
	
	
	proc SetNoBreakInside*(r: Ruler) 
	begin 
		assert(r.style # nil, 20)
		prop.valid := {opts}
		prop.opts.mask := {noBreakInside}
		prop.opts.val_ := {noBreakInside}
		r.style.SetAttr(ModifiedAttr(r.style.attr, prop))
	end SetNoBreakInside
	
	proc SetPageBreak*(r: Ruler) 
	begin 
		assert(r.style # nil, 20)
		prop.valid := {opts}
		prop.opts.mask := {pageBreak}
		prop.opts.val_ := {pageBreak}
		r.style.SetAttr(ModifiedAttr(r.style.attr, prop))
	end SetPageBreak
	
	proc SetParJoin*(r: Ruler) 
	begin 
		assert(r.style # nil, 20)
		prop.valid := {opts}
		prop.opts.mask := {parJoin}
		prop.opts.val_ := {parJoin}
		r.style.SetAttr(ModifiedAttr(r.style.attr, prop))
	end SetParJoin
	
	
	proc AddTab*(r: Ruler; x: integer) 
		var 
			ra: Attributes
			i: integer
	begin 
		assert(r.style # nil, 20)
		ra := r.style.attr
		i := ra.tabs.len_
		assert(i < maxTabs, 21)
		assert((i = 0) or (ra.tabs.tab[i - 1].stop < x), 22)
		prop.valid := {tabs}
		CopyTabs(ra.tabs, ra.tabsData, prop.tabs, prop.tabsData)
		InitTab(x, prop.tabs, prop.tabsData, i)
		inc(prop.tabs.len_)
		r.style.SetAttr(ModifiedAttr(ra, prop))
	end AddTab
	
	proc MakeCenterTab*(r: Ruler) 
		var 
			ra: Attributes
			i: integer
	begin 
		assert(r.style # nil, 20)
		ra := r.style.attr
		i := ra.tabs.len_
		assert(i > 0, 21)
		prop.valid := {tabs}
		CopyTabs(ra.tabs, ra.tabsData, prop.tabs, prop.tabsData)
		prop.tabs.tab[i - 1].type_ := prop.tabs.tab[i - 1].type_ + {centerTab} - {rightTab}
		r.style.SetAttr(ModifiedAttr(ra, prop))
	end MakeCenterTab
	
	proc MakeRightTab*(r: Ruler) 
		var 
			ra: Attributes
			i: integer
	begin 
		assert(r.style # nil, 20)
		ra := r.style.attr
		i := ra.tabs.len_
		assert(i > 0, 21)
		prop.valid := {tabs}
		CopyTabs(ra.tabs, ra.tabsData, prop.tabs, prop.tabsData)
		prop.tabs.tab[i - 1].type_ := prop.tabs.tab[i - 1].type_ - {centerTab} + {rightTab}
		r.style.SetAttr(ModifiedAttr(ra, prop))
	end MakeRightTab
	
	proc MakeBarTab*(r: Ruler) 
		var 
			ra: Attributes
			i: integer
	begin 
		assert(r.style # nil, 20)
		ra := r.style.attr
		i := ra.tabs.len_
		assert(i > 0, 21)
		prop.valid := {tabs}
		CopyTabs(ra.tabs, ra.tabsData, prop.tabs, prop.tabsData)
		prop.tabs.tab[i - 1].type_ := prop.tabs.tab[i - 1].type_ + {barTab}
		r.style.SetAttr(ModifiedAttr(ra, prop))
	end MakeBarTab
	
	proc MakeDecimalTab*(r: Ruler; radixChar: wchar) 
		var 
			ra: Attributes
			i: integer
	begin 
		assert(r.style # nil, 20)
		ra := r.style.attr
		i := ra.tabs.len_
		assert(i > 0, 21)
		prop.valid := {tabs}
		CopyTabs(ra.tabs, ra.tabsData, prop.tabs, prop.tabsData)
		prop.tabs.tab[i - 1].type_ := prop.tabs.tab[i - 1].type_ + {centerTab, rightTab}
		prop.tabsData[i - 1] := radixChar
		r.style.SetAttr(ModifiedAttr(ra, prop))
	end MakeDecimalTab
	
	
	// SetAttrOp
	
	proc (op: SetAttrOp) Do
		var 
			s: Style
			attr: Attributes
			upd: UpdateMsg
	begin 
		s := op.style
		attr := s.attr
		s.attr := op.attr
		op.attr := attr
		// Stores.InitDomain(s.attr, s.Domain());// Stores.Join(s, s.attr);
		assert((s.attr = nil) or Stores.Joined(s, s.attr), 100)
		upd.style := s
		upd.oldAttr := attr
		Models.Domaincast(s.Domain(), upd)
		if tabDialogHook # nil then
			tabDialogHook.Refresh(s) 
		end 
	end Do
	
	proc DoSetAttrOp(s: Style; attr: Attributes) 
		var 
			op: SetAttrOp
	begin 
		if (s.attr # attr) or ~s.attr.Equals(attr) then
			// IF attr.Domain() # s.Domain() THEN attr := Stores.CopyOf(attr)(Attributes) END;
			if ~Stores.Joined(s, attr) then
				if ~Stores.Unattached(attr) then
					attr := Stores.CopyOf(attr)(Attributes) 
				end 
				Stores.Join(s, attr) 
			end 
			new(op)
			op.style := s
			op.attr := attr
			Models.Do(s, rulerChangeKey, op) 
		end 
	end DoSetAttrOp
	
	
	// grid definitions
	
	proc MarginGrid(x: integer): integer 
	begin 
		return (x + marginGrid div 2) div marginGrid * marginGrid
	end MarginGrid
	
	proc TabGrid(x: integer): integer 
	begin 
		return (x + tabGrid div 2) div tabGrid * tabGrid
	end TabGrid
	
	
	// nice graphical primitives
	
	proc DrawCenteredInt(f: Views.Frame; x, y, n: integer) 
		var 
			sw: integer
			s: array 32 of wchar
	begin 
		Strings.IntToString(n, s)
		sw := font.StringWidth(s)
		f.DrawString(x - sw div 2, y, Ports.defaultColor, s, font)
	end DrawCenteredInt
	
	proc DrawNiceRect(f: Views.Frame; l, t, r, b: integer) 
		var 
			u: integer
	begin 
		u := f.dot
		f.DrawRect(l, t, r - u, b - u, 0, Ports.defaultColor)
		f.DrawLine(l + u, b - u, r - u, b - u, u, Ports.grey25)
		f.DrawLine(r - u, t + u, r - u, b - u, u, Ports.grey25)
	end DrawNiceRect
	
	proc DrawScale(f: Views.Frame; l, t, r, b, clipL, clipR: integer) 
		var 
			u, h, x, px, sw: integer
			i, n, d1, d2: integer
			s: array 32 of wchar
	begin 
		f.DrawRect(l, t, r, b, Ports.fill, Ports.grey12)
		u := f.dot
		if Dialog.metricSystem then
			d1 := 2
			d2 := 10 
		else 
			d1 := 2
			d2 := 16 
		end 
		dec(b, point)
		sw := 2 * u + font.StringWidth("8888888888")
		x := l + tabGrid
		i := 0
		n := 0
		while x <= r do 
			inc(i)
			px := TabGrid(x)
			if i = d2 then
				h := 6 * point
				i := 0
				inc(n)
				if (px >= clipL - sw) & (px < clipR) then
					Strings.IntToString(n, s)
					f.DrawString(px - 2 * u - font.StringWidth(s), b - 3 * point, Ports.defaultColor, s, font) 
				end  
			elsif i mod d1 = 0 then 
				h := 2 * point 
			else 
				h := 0 
			end 
			if (px >= clipL) & (px < clipR) & (h > 0) then
				f.DrawLine(px, b, px, b - h, 0, Ports.defaultColor) 
			end 
			inc(x, tabGrid) 
		end 
	end DrawScale
	
	proc InvertTabMark(f: Views.Frame; l, t, r, b: integer; type_: set; show: boolean) 
		var 
			u, u3, u6, x, left, top, right, bottom: integer
	begin 
		u := f.dot
		u3 := u * 3
		u6 := u3 * 2
		if ~odd((r - l) div u) then
			dec(r, u) 
		end 
		x := l + (r - l) div u div 2 * u
		left := x - u
		top := t + u
		right := x + u
		bottom := t + u6
		f.MarkRect(left, top, right, bottom, Ports.fill, Ports.invert, show) // vertical stem
		if type_ * {centerTab, rightTab} = {centerTab, rightTab} then
			f.MarkRect(right + u, bottom - u3, right + u3, bottom - u, Ports.fill, Ports.invert, show)  // decimal point
		end 
		top := bottom
		bottom := bottom + u * 2
		if centerTab in type_ then
			left := left - u3
			right := right + u3 
		elsif rightTab in type_ then 
			left := x - u6 
		else  // left tab
			right := x + u6 
		end 
		f.MarkRect(left, top, right, bottom, Ports.fill, Ports.invert, show) // horizontal stem
		if barTab in type_ then
			left := x
			top := bottom
			right := x + u
			bottom := bottom + u3
			f.MarkRect(left, top, right, bottom, Ports.fill, Ports.invert, show)  // small vertical line
		end 
	end InvertTabMark
	
	proc InvertFirstMark(f: Views.Frame; l, t, r, b: integer; show: boolean) 
		var 
			u, i, ih: integer
	begin 
		u := f.dot
		i := b - t
		t := b - u
		ih := r - l
		while (i > 0) & (r > l) do 
			dec(i, u)
			f.MarkRect(l, t, r, b, Ports.fill, Ports.invert, show)
			if i <= ih then
				dec(r, u) 
			end 
			dec(t, u)
			dec(b, u) 
		end 
	end InvertFirstMark
	
	proc InvertLeftMark(f: Views.Frame; l, t, r, b: integer; show: boolean) 
		var 
			u, i, ih: integer
	begin 
		u := f.dot
		i := b - t
		b := t + u
		ih := r - l
		while (i > 0) & (r > l) do 
			dec(i, u)
			f.MarkRect(l, t, r, b, Ports.fill, Ports.invert, show)
			if i <= ih then
				dec(r, u) 
			end 
			inc(t, u)
			inc(b, u) 
		end 
	end InvertLeftMark
	
	proc InvertRightMark(f: Views.Frame; l, t, r, b: integer; show: boolean) 
		var 
			u, i, ih: integer
	begin 
		u := f.dot
		if ~odd((b - t) div u) then
			inc(t, u) 
		end 
		ih := r - l
		l := r - u
		i := b - t
		b := t + u
		while (i > 0) & (i > ih) do 
			dec(i, u)
			f.MarkRect(l, t, r, b, Ports.fill, Ports.invert, show)
			dec(l, u)
			inc(t, u)
			inc(b, u) 
		end 
		while (i > 0) & (r > l) do 
			dec(i, u)
			f.MarkRect(l, t, r, b, Ports.fill, Ports.invert, show)
			inc(l, u)
			inc(t, u)
			inc(b, u) 
		end 
	end InvertRightMark
	
	
	// marks
	
	proc SetMark(var m: Mark; r: StdRuler; px, py: integer; kind, index: integer) 
	begin 
		m.ruler := r
		m.kind := kind
		m.px := px
		m.py := py
		case kind of 
			first: 
				m.l := px
				m.r := m.l + 4 * point
				m.b := py - 7 * point
				m.t := m.b - 4 * point 
			| left: 
				m.l := px
				m.r := m.l + 4 * point
				m.b := py - 2 * point
				m.t := m.b - 4 * point 
			| right: 
				m.r := px
				m.l := m.r - 4 * point
				m.b := py - 3 * point
				m.t := m.b - 7 * point 
			| tabs: 
				m.l := px - 4 * point
				m.r := m.l + 9 * point
				m.b := py - 5 * point
				m.t := m.b - 6 * point
				m.type_ := r.style.attr.tabs.tab[index].type_ 
			| firstIcon .. lastIcon: 
				m.l := px
				m.r := px + iconWidth
				m.t := py
				m.b := py + iconHeight 
		else 
			halt(100) 
		end 
	end SetMark
	
	proc Try(var m: Mark; r: StdRuler; px, py, x, y: integer; kind, index: integer) 
	begin 
		if m.kind = invalid then
			SetMark(m, r, px, py, kind, index)
			if (m.l - point <= x) & (x < m.r + point) & (m.t - point <= y) & (y < m.b + point) then
				m.px0 := m.px
				m.py0 := m.py
				m.x := x
				m.y := y
				if kind = tabs then
					m.index := index
					CopyTabs(r.style.attr.tabs, r.style.attr.tabsData, m.tabs, m.tabsData) 
				end  
			else 
				m.kind := invalid 
			end  
		end 
	end Try
	
	proc InvertMark(var m: Mark; f: Views.Frame; show: boolean) 
	// pre: kind # invalid
	begin 
		case m.kind of 
			first: 
				InvertFirstMark(f, m.l, m.t, m.r, m.b, show) 
			| left: 
				InvertLeftMark(f, m.l, m.t, m.r, m.b, show) 
			| right: 
				InvertRightMark(f, m.l, m.t, m.r, m.b, show) 
			| tabs: 
				InvertTabMark(f, m.l, m.t, m.r, m.b, m.type_, show) 
		end 
	end InvertMark
	
	proc HiliteMark(var m: Mark; f: Views.Frame; show: boolean) 
	begin 
		f.MarkRect(m.l, m.t, m.r - point, m.b - point, Ports.fill, Ports.hilite, show)
	end HiliteMark
	
	proc HiliteThisMark(r: StdRuler; f: Views.Frame; kind: integer; show: boolean) 
		var 
			m: Mark
			px, w, h: integer
	begin 
		if (kind # invalid) & (kind in validIcons) then
			px := iconGap + (kind - firstIcon) * (iconWidth + iconGap)
			r.context.GetSize(w, h)
			SetMark(m, r, px, h - iconPin, kind, -1)
			HiliteMark(m, f, show) 
		end 
	end HiliteThisMark
	
	proc DrawMark(var m: Mark; f: Views.Frame) 
		// pre: kind # invalid
		var 
			a: Attributes
			l, t, r, b, y, d, asc, dsc, fw: integer
			i: integer
			w: array 4 of integer
			points: array 3 of Ports.Point
	begin 
		a := m.ruler.style.attr
		l := m.l + 2 * point
		t := m.t + 2 * point
		r := m.r - 4 * point
		b := m.b - 3 * point
		font.GetBounds(asc, dsc, fw)
		y := (m.t + m.b + asc) div 2
		w[0] := (r - l) div 2
		w[1] := r - l
		w[2] := (r - l) div 3
		w[3] := (r - l) * 2 div 3
		case m.kind of 
			rightToggle: 
				if rightFixed in a.opts then
					points[0].x := ((l + r) div 2 + point * 2) div f.dot * f.dot
					points[0].y := t div f.dot * f.dot
					points[1].x := points[0].x
					points[1].y := points[0].y + f.dot * 8
					points[2].x := points[0].x - f.dot * 4
					points[2].y := points[0].y + f.dot * 4
					f.DrawPath(points, 3, Ports.fill, Ports.defaultColor, Ports.closedPoly) 
				else 
					dec(b, point)
					f.DrawLine(l, t, r, t, point, Ports.defaultColor)
					f.DrawLine(l, b, r, b, point, Ports.defaultColor)
					f.DrawLine(l, t, l, b, point, Ports.defaultColor)
					f.DrawLine(r, t, r, b, point, Ports.defaultColor) 
				end  
			| gridDec: 
				while t < b do 
					f.DrawLine(l, t, r, t, point, Ports.defaultColor)
					inc(t, 2 * point) 
				end  
			| gridVal: 
				DrawCenteredInt(f, (l + r) div 2, y, a.grid div point) 
			| gridInc: 
				while t < b do 
					f.DrawLine(l, t, r, t, point, Ports.defaultColor)
					inc(t, 3 * point) 
				end  
			| leftFlush: 
				i := 0
				while t < b do 
					d := w[i]
					i := (i + 1) mod len(w)
					f.DrawLine(l, t, l + d, t, point, Ports.defaultColor)
					inc(t, 2 * point) 
				end  
			| centered: 
				i := 0
				while t < b do 
					d := (r - l - w[i]) div 2
					i := (i + 1) mod len(w)
					f.DrawLine(l + d, t, r - d, t, point, Ports.defaultColor)
					inc(t, 2 * point) 
				end  
			| rightFlush: 
				i := 0
				while t < b do 
					d := w[i]
					i := (i + 1) mod len(w)
					f.DrawLine(r - d, t, r, t, point, Ports.defaultColor)
					inc(t, 2 * point) 
				end  
			| justified: 
				while t < b do 
					f.DrawLine(l, t, r, t, point, Ports.defaultColor)
					inc(t, 2 * point) 
				end  
			| leadDec: 
				f.DrawLine(l, t, l, t + point, point, Ports.defaultColor)
				inc(t, 2 * point)
				while t < b do 
					f.DrawLine(l, t, r, t, point, Ports.defaultColor)
					inc(t, 2 * point) 
				end  
			| leadVal: 
				DrawCenteredInt(f, (l + r) div 2, y, m.ruler.style.attr.lead div point) 
			| leadInc: 
				f.DrawLine(l, t, l, t + 3 * point, point, Ports.defaultColor)
				inc(t, 4 * point)
				while t < b do 
					f.DrawLine(l, t, r, t, point, Ports.defaultColor)
					inc(t, 2 * point) 
				end  
			| pageBrk: 
				dec(b, point)
				if pageBreak in a.opts then
					y := (t + b) div 2 - point
					f.DrawLine(l, t, l, y, point, Ports.defaultColor)
					f.DrawLine(r, t, r, y, point, Ports.defaultColor)
					f.DrawLine(l, y, r, y, point, Ports.defaultColor)
					inc(y, 2 * point)
					f.DrawLine(l, y, r, y, point, Ports.defaultColor)
					f.DrawLine(l, y, l, b, point, Ports.defaultColor)
					f.DrawLine(r, y, r, b, point, Ports.defaultColor) 
				else 
					f.DrawLine(l, t, l, b, point, Ports.defaultColor)
					f.DrawLine(r, t, r, b, point, Ports.defaultColor) 
				end  
		else 
			halt(100) 
		end 
		if ~(m.kind in {gridVal, leadVal}) then
			DrawNiceRect(f, m.l, m.t, m.r, m.b) 
		end 
	end DrawMark
	
	proc GetMark(var m: Mark; r: StdRuler; f: Views.Frame
		x, y: integer; canCreate: boolean
		) 
		// pre: ~canCreate OR (f # NIL)
		var 
			a: Attributes
			px, w, h: integer
			i: integer
	begin 
		m.kind := invalid
		m.dirty := false
		a := r.style.attr
		r.context.GetSize(w, h)
		
		// first try scale
		Try(m, r, a.first, h, x, y, first, 0)
		Try(m, r, a.left, h, x, y, left, 0)
		if rightFixed in a.opts then
			Try(m, r, a.right, h, x, y, right, 0) 
		end 
		i := 0
		while (m.kind = invalid) & (i < a.tabs.len_) do 
			Try(m, r, a.tabs.tab[i].stop, h, x, y, tabs, i)
			inc(i) 
		end 
		if (m.kind = invalid) & (y >= h - tabBarHeight) & (a.tabs.len_ < maxTabs) then
			i := 0
			px := TabGrid(x)
			while (i < a.tabs.len_) & (a.tabs.tab[i].stop < px) do 
				inc(i) 
			end 
			if (i = 0) or (px - a.tabs.tab[i - 1].stop >= minTabWidth) then
				if (i = a.tabs.len_) or (a.tabs.tab[i].stop - px >= minTabWidth) then
					if canCreate then // set new tab stop, initially at end of list
						m.kind := tabs
						m.index := a.tabs.len_
						m.dirty := true
						CopyTabs(a.tabs, a.tabsData, m.tabs, m.tabsData)
						m.tabs.len_ := a.tabs.len_ + 1
						InitTab(px, m.tabs, m.tabsData, a.tabs.len_)
						InitTab(px, a.tabs, a.tabsData, a.tabs.len_)
						SetMark(m, r, px, h, tabs, m.index)
						InvertMark(m, f, Ports.show)
						m.px0 := m.px
						m.py0 := m.py
						m.x := x
						m.y := y 
					end  
				end  
			end  
		end 
		
		// next try icon bar
		px := iconGap
		i := firstIcon
		while i <= lastIcon do 
			if i in validIcons then
				Try(m, r, px, h - iconPin, x, y, i, 0) 
			end 
			inc(px, iconWidth + iconGap)
			inc(i) 
		end 
	end GetMark
	
	proc SelectMark(r: StdRuler; f: Views.Frame; in m: Mark) 
	begin 
		r.sel := m.kind
		r.px := m.px
		r.py := m.py
	end SelectMark
	
	proc DeselectMark(r: StdRuler; f: Views.Frame) 
	begin 
		HiliteThisMark(r, f, r.sel, Ports.hide)
		r.sel := invalid
	end DeselectMark
	
	
	// mark interaction
	
	proc Mode(r: StdRuler): integer 
		var 
			a: Attributes
			i: integer
	begin 
		a := r.style.attr
		if a.opts * adjMask = {leftAdjust} then
			i := leftFlush 
		elsif a.opts * adjMask = {} then 
			i := centered 
		elsif a.opts * adjMask = {rightAdjust} then 
			i := rightFlush 
		else  // a.opts * adjMask = adjMask
			i := justified 
		end 
		return i
	end Mode
	
	proc GrabMark(var m: Mark; r: StdRuler; f: Views.Frame; x, y: integer; canCreate: boolean) 
	begin 
		GetMark(m, r, f, x, y, canCreate)
		DeselectMark(r, f)
		if m.kind = Mode(r) then
			m.kind := invalid 
		end 
	end GrabMark
	
	proc TrackMark(var m: Mark; f: Views.Frame; x, y: integer; modifiers: set) 
		var 
			px, py, w, h: integer
	begin 
		if m.kind # invalid then
			px := m.px + x - m.x
			py := m.py + y - m.y
			if m.kind = tabs then
				px := TabGrid(px) 
			elsif m.kind in validIcons then 
				if (m.l <= x) & (x < m.r) then
					px := 1 
				else 
					px := 0 
				end  
			else 
				px := MarginGrid(px) 
			end 
			if m.kind in {right, tabs} then
				m.ruler.context.GetSize(w, h)
				if (0 <= y) & (y < h + scaleHeight) or (Controllers.extend in modifiers) then
					py := h 
				else 
					py := -1  // moved mark out of ruler: delete tab stop or fixed right margin
				end  
			elsif m.kind in validIcons then 
				if (m.t <= y) & (y < m.b) then
					py := 1 
				else 
					py := 0 
				end  
			else 
				py := MarginGrid(py) 
			end 
			if (m.kind in {right, tabs}) & ((m.px # px) or (m.py # py)) then
				inc(m.x, px - m.px)
				inc(m.y, py - m.py)
				InvertMark(m, f, Ports.hide)
				SetMark(m, m.ruler, px, py, m.kind, m.index)
				InvertMark(m, f, Ports.show)
				m.dirty := true 
			elsif (m.kind in {first, left}) & (m.px # px) then 
				inc(m.x, px - m.px)
				InvertMark(m, f, Ports.hide)
				SetMark(m, m.ruler, px, m.py, m.kind, m.index)
				InvertMark(m, f, Ports.show) 
			elsif (m.kind in validIcons) & (m.px * m.py # px * py) then 
				HiliteMark(m, f, Ports.show)
				if m.kind in modeIcons then
					HiliteThisMark(m.ruler, f, Mode(m.ruler), Ports.hide) 
				end 
				m.px := px
				m.py := py 
			end  
		end 
	end TrackMark
	
	proc ShiftMarks(a: Attributes; p: Prop; mask: set; x0, dx: integer) 
		var 
			new_: set
			i, j, t0, t1: integer
			tab0, tab1: TabArray
			tab0Data, tab1Data: TabData
	begin 
		new_ := mask - p.valid
		if first in new_ then
			p.first := a.first 
		end 
		if tabs in new_ then
			CopyTabs(a.tabs, a.tabsData, p.tabs, p.tabsData) 
		end 
		p.valid := p.valid + mask
		if first in mask then
			inc(p.first, dx) 
		end 
		if tabs in mask then
			i := 0
			while (i < p.tabs.len_) & (p.tabs.tab[i].stop < x0) do 
				CopyTab(p.tabs, p.tabsData, i, tab0, tab0Data, i)
				inc(i) 
			end 
			t0 := i
			t1 := 0
			while i < p.tabs.len_ do 
				CopyTab(p.tabs, p.tabsData, i, tab1, tab1Data, t1)
				inc(tab1.tab[t1].stop, dx)
				inc(t1)
				inc(i) 
			end 
			i := 0
			j := 0
			p.tabs.len_ := 0
			while i < t0 do  // merge sort
				while (j < t1) & (tab1.tab[j].stop < tab0.tab[i].stop) do 
					CopyTab(tab1, tab1Data, j, p.tabs, p.tabsData, p.tabs.len_)
					inc(p.tabs.len_)
					inc(j) 
				end 
				if (j < t1) & (tab1.tab[j].stop = tab0.tab[i].stop) then
					inc(j) 
				end 
				CopyTab(tab0, tab0Data, i, p.tabs, p.tabsData, p.tabs.len_)
				inc(p.tabs.len_)
				inc(i) 
			end 
			while j < t1 do 
				CopyTab(tab1, tab1Data, j, p.tabs, p.tabsData, p.tabs.len_)
				inc(p.tabs.len_)
				inc(j) 
			end  
		end 
	end ShiftMarks
	
	proc ShiftDependingMarks(var m: Mark; p: Prop) 
		var 
			a: Attributes
			dx, i: integer
	begin 
		a := m.ruler.style.attr
		dx := m.px - m.px0
		case m.kind of 
			first: 
				ShiftMarks(a, p, {tabs}, 0, dx) 
			| left: 
				ShiftMarks(a, p, {first, tabs}, 0, dx) 
			| tabs: 
				ShiftMarks(a, p, {tabs}, m.px0, dx)
				i := 0
				while (i < p.tabs.len_) & (m.px # p.tabs.tab[i].stop) do 
					inc(i) 
				end 
				m.index := i 
		else  
		end 
	end ShiftDependingMarks
	
	proc AdjustMarks(var m: Mark; f: Views.Frame; modifiers: set) 
		var 
			r: StdRuler
			a: Attributes
			p: Prop
			g: integer
			i, j: integer
			modify: boolean
			type_: set
	begin 
		r := m.ruler
		if (m.kind # invalid) & (m.kind in validIcons) 
			& (m.px = 1) & (m.py = 1) 
			or (m.kind # invalid) & ~(m.kind in validIcons) 
			& ((m.px # m.px0) or (m.py # m.py0) 
			or (m.kind = tabs)(* (m.tabs.len # r.style.attr.tabs.len) *)) 
		then
			a := r.style.attr
			new(p)
			p.valid := {}
			modify := (Controllers.modify in modifiers) & (m.tabs.len_ = r.style.attr.tabs.len_)
			case m.kind of 
				first: 
					p.valid := {first}
					p.first := m.px 
				| left: 
					p.valid := {left}
					p.left := m.px 
				| right: 
					if m.py >= 0 then
						p.valid := {right}
						p.right := m.px 
					else 
						p.valid := {opts}
						p.opts.val_ := {}
						p.opts.mask := {rightFixed} 
					end  
				| tabs: 
					if ~m.dirty then
						p.valid := {tabs}
						CopyTabs(m.tabs, m.tabsData, p.tabs, p.tabsData)
						i := m.index
						type_ := m.tabs.tab[i].type_
						if modify then
							type_ := type_ * {barTab}
							if type_ = {} then
								type_ := {barTab} 
							else 
								type_ := {} 
							end 
							p.tabs.tab[i].type_ := p.tabs.tab[i].type_ - {barTab} + type_ 
						else 
							type_ := type_ * {centerTab, rightTab}
							if type_ = {} then
								type_ := {centerTab} 
							elsif type_ = {centerTab} then 
								type_ := {rightTab} 
							elsif type_ = {rightTab} then 
								type_ := {centerTab, rightTab} 
							else 
								type_ := {} 
							end 
							p.tabs.tab[i].type_ := p.tabs.tab[i].type_ - {centerTab, rightTab} + type_ 
						end  
					elsif ~modify then 
						p.valid := {tabs}
						p.tabs.len_ := m.tabs.len_ - 1
						i := 0
						while i < m.index do 
							CopyTab(m.tabs, m.tabsData, i, p.tabs, p.tabsData, i)
							inc(i) 
						end 
						inc(i)
						while i < m.tabs.len_ do 
							CopyTab(m.tabs, m.tabsData, i, p.tabs, p.tabsData, i - 1)
							inc(i) 
						end 
						i := 0
						while (i < p.tabs.len_) & (p.tabs.tab[i].stop < m.px) do 
							inc(i) 
						end 
						if (m.px >= min(a.first, a.left)) & (m.px <= f.r) & (m.py >= 0) 
							& ((i = 0) or (m.px - p.tabs.tab[i - 1].stop >= minTabWidth)) 
							& ((i = p.tabs.len_) or (p.tabs.tab[i].stop - m.px >= minTabWidth)) then
							j := p.tabs.len_
							while j > i do 
								CopyTab(p.tabs, p.tabsData, j - 1, p.tabs, p.tabsData, j)
								dec(j) 
							end 
							CopyTab(m.tabs, m.tabsData, m.index, p.tabs, p.tabsData, i)
							p.tabs.tab[i].stop := m.px
							inc(p.tabs.len_) 
						end 
						m.index := i
						i := 0
						while (i < p.tabs.len_) 
							& (p.tabs.tab[i].stop = a.tabs.tab[i].stop) 
							& (p.tabs.tab[i].type_ = a.tabs.tab[i].type_) do 
							inc(i) 
						end 
						if (i = p.tabs.len_) & (p.tabs.len_ = a.tabs.len_) then // did not change
							return  
						end  
					end  
				| rightToggle: 
					p.valid := {right, opts}
					if ~(rightFixed in a.opts) then
						p.right := f.r div marginGrid * marginGrid 
					end 
					p.opts.val_ := a.opts / {rightFixed}
					p.opts.mask := {rightFixed} 
				| gridDec: 
					p.valid := {asc, grid}
					g := a.grid - point
					if g = 0 then
						p.grid := 1
						p.asc := 0 
					else 
						p.grid := g
						p.asc := g - a.dsc 
					end  
				| gridVal: 
					SelectMark(r, f, m)
					return  
				| gridInc: 
					p.valid := {asc, grid}
					g := a.grid + point
					dec(g, g mod point)
					p.grid := g
					p.asc := g - a.dsc 
				| leftFlush: 
					p.valid := {opts}
					p.opts.val_ := {leftAdjust}
					p.opts.mask := adjMask 
				| centered: 
					p.valid := {opts}
					p.opts.val_ := {}
					p.opts.mask := adjMask 
				| rightFlush: 
					p.valid := {opts}
					p.opts.val_ := {rightAdjust}
					p.opts.mask := adjMask 
				| justified: 
					p.valid := {opts}
					p.opts.val_ := adjMask
					p.opts.mask := adjMask 
				| leadDec: 
					p.valid := {lead}
					p.lead := a.lead - point 
				| leadVal: 
					SelectMark(r, f, m)
					return  
				| leadInc: 
					p.valid := {lead}
					p.lead := a.lead + point 
				| pageBrk: 
					p.valid := {opts}
					p.opts.val_ := a.opts / {pageBreak}
					p.opts.mask := {pageBreak} 
			else 
				halt(100) 
			end 
			if modify then
				ShiftDependingMarks(m, p) 
			end 
			if m.kind in validIcons - modeIcons then
				HiliteMark(m, f, Ports.hide) 
			end 
			r.style.SetAttr(ModifiedAttr(a, p)) 
		end 
	end AdjustMarks
	
	proc OpenTabDlg(r: Ruler; tabIndex: integer) 
		var 
			tc: Kernel.Module
	begin 
		if tabDialogHook = nil then
			tc := Kernel.ThisMod("TextCmds") 
		end 
		if tabDialogHook # nil then
			tabDialogHook.Open(r, tabIndex) 
		end 
	end OpenTabDlg
	
	proc InitTabDlg(r: Ruler; tabIndex: integer) 
	begin 
		if tabDialogHook # nil then
			tabDialogHook.Init(r, min(tabIndex, r.style.attr.tabs.len_ - 1)) 
		end 
	end InitTabDlg
	
	// primitivies for standard ruler
	
	proc Track(r: StdRuler; f: Views.Frame; in msg: Controllers.TrackMsg) 
		var 
			m: Mark
			x, y, res: integer
			modifiers: set
			isDown: boolean
			cmd: array 128 of wchar
			popup: boolean
	begin 
		popup := Controllers.popup in msg.modifiers
		GrabMark(m, r, f, msg.x, msg.y, ~popup)
		if (m.kind = tabs) & popup then
			repeat 
				f.Input(x, y, modifiers, isDown) 
			until ~isDown 
			OpenTabDlg(r, m.index) 
		else 
			repeat 
				f.Input(x, y, modifiers, isDown)
				TrackMark(m, f, x, y, modifiers) 
			until ~isDown 
			AdjustMarks(m, f, modifiers)
			if Controllers.doubleClick in msg.modifiers then
				case m.kind of 
					| invalid: 
						Dialog.MapString("#Text:OpenRulerDialog", cmd)
						Dialog.Call(cmd, "", res) 
					| gridVal, leadVal: 
						Dialog.MapString("#Text:OpenSizeDialog", cmd)
						Dialog.Call(cmd, "", res) 
					| tabs: 
						InitTabDlg(r, m.index) 
				else  
				end  
			elsif m.kind = tabs then 
				InitTabDlg(r, m.index) 
			end  
		end 
	end Track
	
	proc Edit(r: StdRuler; f: Views.Frame; var msg: Controllers.EditMsg) 
		var 
			v: Views.View
	begin 
		case msg.op of 
			Controllers.copy_: 
				msg.view := Views.CopyOf(r, Views.deep)
				msg.isSingle := true 
			| Controllers.paste: 
				v := msg.view
				with v: Ruler do 
					r.style.SetAttr(v.style.attr) 
				else  
				end  
		else  
		end 
	end Edit
	
	proc PollOps(r: StdRuler; f: Views.Frame; var msg: Controllers.PollOpsMsg) 
	begin 
		msg.type_ := "TextRulers.Ruler"
		msg.pasteType := "TextRulers.Ruler"
		msg.selectable := false
		msg.valid := {Controllers.copy_, Controllers.paste}
	end PollOps
	
	proc SetProp(r: StdRuler; var msg: Properties.SetMsg; var requestFocus: boolean) 
		var 
			a1: Attributes
			px, py, g: integer
			sel: integer
			p: Properties.Property
			sp: Properties.StdProp
			rp: Prop
	begin 
		p := msg.prop
		sel := r.sel
		px := r.px
		py := r.py
		if sel # invalid then
			while (p # nil) & ~(p is Properties.StdProp) do 
				p := p.next 
			end 
			if p # nil then
				sp := p(Properties.StdProp)
				if (r.sel = leadVal) & (Properties.size_ in sp.valid) then
					new(rp)
					rp.valid := {lead}
					rp.lead := sp.size_ 
				elsif (r.sel = gridVal) & (Properties.size_ in sp.valid) then 
					g := sp.size_
					dec(g, g mod point)
					new(rp)
					rp.valid := {asc, grid}
					if g = 0 then
						rp.asc := 0
						rp.grid := 1 
					else 
						rp.asc := g - r.style.attr.dsc
						rp.grid := g 
					end  
				else 
					rp := nil 
				end  
			end 
			p := rp 
		end 
		a1 := ModifiedAttr(r.style.attr, p)
		if ~a1.Equals(r.style.attr) then
			r.style.SetAttr(a1)
			if requestFocus & (r.sel = invalid) then // restore mark selection
				r.sel := sel
				r.px := px
				r.py := py 
			end  
		else 
			requestFocus := false 
		end 
	end SetProp
	
	proc PollProp(r: StdRuler; var msg: Properties.PollMsg) 
		var 
			p: Properties.StdProp
	begin 
		case r.sel of 
			invalid: 
				msg.prop := r.style.attr.Prop() 
			| leadVal: 
				new(p)
				p.known := {Properties.size_}
				p.valid := p.known
				p.size_ := r.style.attr.lead
				msg.prop := p 
			| gridVal: 
				new(p)
				p.known := {Properties.size_}
				p.valid := p.known
				p.size_ := r.style.attr.grid
				msg.prop := p 
		else 
			halt(100) 
		end 
	end PollProp
	
	
	// StdStyle
	
	proc (r: StdStyle) Internalize(var rd: Stores.Reader) 
		var 
			thisVersion: integer
	begin 
		r.Internalize^(rd)
		if rd.cancelled then
			return  
		end 
		rd.ReadVersion(minVersion, maxStdStyleVersion, thisVersion)
	end Internalize
	
	proc (r: StdStyle) Externalize(var wr: Stores.Writer) 
	begin 
		r.Externalize^(wr)
		wr.WriteVersion(maxStdStyleVersion)
	end Externalize
	(* PROCEDURE (r: StdStyle) CopyFrom (source: Stores.Store);
	   BEGIN
	   r.SetAttr(source(StdStyle).attr)
	   END CopyFrom; *)
	
	
	
	// StdRuler
	
	proc (r: StdRuler) Internalize(var rd: Stores.Reader) 
		var 
			thisVersion: integer
	begin 
		r.Internalize^(rd)
		if rd.cancelled then
			return  
		end 
		rd.ReadVersion(minVersion, maxStdRulerVersion, thisVersion)
		if rd.cancelled then
			return  
		end 
		r.sel := invalid
	end Internalize
	
	proc (r: StdRuler) Externalize(var wr: Stores.Writer) 
	begin 
		r.Externalize^(wr)
		wr.WriteVersion(maxStdRulerVersion)
	end Externalize
	
	proc (r: StdRuler) ThisModel(): Models.Model 
	begin 
		return r.style
	end ThisModel
	
	proc (r: StdRuler) CopyFromModelView(source: Views.View; model: Models.Model) 
	begin 
		r.sel := invalid
		r.InitStyle(model(Style))
	end CopyFromModelView
	
	proc (ruler: StdRuler) Restore(f: Views.Frame; l, t, r, b: integer) 
		var 
			a: Attributes
			m: Mark
			u, scale, tabBar, px, w, h: integer
			i: integer
	begin 
		u := f.dot
		a := ruler.style.attr
		ruler.context.GetSize(w, h)
		tabBar := h - tabBarHeight
		scale := tabBar - scaleHeight
		w := min(f.r + 10 * mm, 10000 * mm) // high-level clipping
		f.DrawLine(0, scale - u, w - u, scale - u, u, Ports.grey25)
		f.DrawLine(0, tabBar - u, w - u, tabBar - u, u, Ports.grey50)
		DrawScale(f, 0, scale, w, tabBar, l, r)
		DrawNiceRect(f, 0, h - rulerHeight, w, h)
		SetMark(m, ruler, a.first, h, first, -1)
		InvertMark(m, f, Ports.show)
		SetMark(m, ruler, a.left, h, left, -1)
		InvertMark(m, f, Ports.show)
		if rightFixed in a.opts then
			SetMark(m, ruler, a.right, h, right, -1)
			InvertMark(m, f, Ports.show) 
		end 
		i := 0
		while i < a.tabs.len_ do 
			SetMark(m, ruler, a.tabs.tab[i].stop, h, tabs, i)
			InvertMark(m, f, Ports.show)
			inc(i) 
		end 
		px := iconGap
		i := firstIcon
		while i <= lastIcon do 
			if i in validIcons then
				SetMark(m, ruler, px, h - iconPin, i, -1)
				DrawMark(m, f) 
			end 
			inc(px, iconWidth + iconGap)
			inc(i) 
		end 
		HiliteThisMark(ruler, f, Mode(ruler), Ports.show)
	end Restore
	
	proc (ruler: StdRuler) RestoreMarks(f: Views.Frame; l, t, r, b: integer) 
	begin 
		HiliteThisMark(ruler, f, ruler.sel, Ports.show)
	end RestoreMarks
	
	proc (r: StdRuler) GetBackground(var color: Ports.Color) 
	begin 
		color := Ports.background
	end GetBackground
	
	proc (r: StdRuler) Neutralize
		var 
			msg: NeutralizeMsg
	begin 
		Views.Broadcast(r, msg)
	end Neutralize
	
	proc (r: StdRuler) HandleModelMsg(var msg: Models.Message) 
	begin 
		with msg: UpdateMsg do 
			Views.Update(r, Views.keepFrames) 
		else  
		end 
	end HandleModelMsg
	
	proc (r: StdRuler) HandleViewMsg(f: Views.Frame; var msg: Views.Message) 
	begin 
		with msg: NeutralizeMsg do 
			DeselectMark(r, f) 
		else  
		end 
	end HandleViewMsg
	
	proc (r: StdRuler) HandleCtrlMsg(f: Views.Frame
		var msg: Controllers.Message; var focus: Views.View
		) 
		var 
			requestFocus: boolean
	begin 
		with msg: Controllers.TrackMsg do 
			Track(r, f, msg) 
		| msg: Controllers.EditMsg do 
			Edit(r, f, msg) 
		| msg: Controllers.MarkMsg do 
			r.RestoreMarks(f, f.l, f.t, f.r, f.b) 
		| msg: Controllers.SelectMsg do 
			if ~msg.set_ then
				DeselectMark(r, f) 
			end  
		| msg: Controllers.PollOpsMsg do 
			PollOps(r, f, msg) 
		| msg: Properties.CollectMsg do 
			PollProp(r, msg.poll) 
		| msg: Properties.EmitMsg do 
			requestFocus := f.front
			SetProp(r, msg.set_, requestFocus)
			msg.requestFocus := requestFocus 
		else  
		end 
	end HandleCtrlMsg
	
	proc (r: StdRuler) HandlePropMsg(var msg: Properties.Message) 
		var 
			m: Mark
			requestFocus: boolean
			w, h: integer
	begin 
		with msg: Properties.SizePref do 
			msg.w := 10000 * Ports.mm
			msg.h := rulerHeight 
		| msg: Properties.ResizePref do 
			msg.fixed := true 
		| msg: Properties.FocusPref do 
			if msg.atLocation then
				r.context.GetSize(w, h)
				GetMark(m, r, nil, msg.x, msg.y, false)
				msg.hotFocus := (m.kind # invalid) & ~(m.kind in fieldIcons) or (msg.y >= h - tabBarHeight)
				msg.setFocus := ~msg.hotFocus 
			end  
		| msg: TextModels.Pref do 
			msg.opts := {TextModels.maskChar, TextModels.hideable}
			msg.mask := TextModels.para 
		| msg: Properties.SetMsg do 
			requestFocus := false
			SetProp(r, msg, requestFocus) 
		| msg: Properties.PollMsg do 
			PollProp(r, msg) 
		else  
		end 
	end HandlePropMsg
	
	
	// StdDirectory
	
	proc (d: StdDirectory) NewStyle(attr: Attributes): Style 
		var 
			s: StdStyle
	begin 
		if attr = nil then
			attr := d.attr 
		end 
		new(s)
		s.SetAttr(attr)
		return s
	end NewStyle
	
	proc (d: StdDirectory) New(style: Style): Ruler 
		var 
			r: StdRuler
	begin 
		if style = nil then
			style := d.NewStyle(nil) 
		end 
		new(r)
		r.InitStyle(style)
		r.sel := invalid
		return r
	end New
	
	
	// miscellaneous
	
	proc GetValidRuler*(text: TextModels.Model; pos, hint: integer
		var ruler: Ruler; var rpos: integer
		) 
		// pre: (hint < 0   OR   (ruler, rpos) is first ruler before hint  &  0 <= pos <= t.Length()
		(* post: hint < rpos <= pos & rpos = Pos(ruler) & (no ruler in (rpos, pos])
		   OR   ((ruler, rpos) unmodified) *)
		
		var 
			view: Views.View
	begin 
		if pos < text.Length() then // let a ruler dominate its own position
			inc(pos) 
		end 
		if pos < hint then
			hint := -1 
		end 
		globRd := text.NewReader(globRd)
		globRd.SetPos(pos)
		repeat 
			globRd.ReadPrevView(view) 
		until globRd.eot or (view is Ruler) or (globRd.Pos() < hint) 
		if (view # nil) & (view is Ruler) then
			ruler := view(Ruler)
			rpos := globRd.Pos() 
		end 
	end GetValidRuler
	
	proc SetDir*(d: Directory) 
	// pre: d # NIL, d.attr # NIL
	// post: dir = d
	begin 
		assert(d # nil, 20)
		assert(d.attr.init, 21)
		dir := d
	end SetDir
	
	
	proc Init
		var 
			d: StdDirectory
			fnt: Fonts.Font
			asc, dsc, w: integer
	begin 
		defaultRadixChar := "."
		if Dialog.metricSystem then
			marginGrid := 1 * mm
			minTabWidth := 1 * mm
			tabGrid := 1 * mm 
		else 
			marginGrid := inch16
			minTabWidth := inch16
			tabGrid := inch16 
		end 
		
		fnt := Fonts.dir.Default()
		font := Fonts.dir.This(fnt.typeface, 7 * point, {}, Fonts.normal) // font for ruler scales
		new(prop)
		prop.valid := {first..tabs}
		prop.first := 0
		prop.left := 0
		if Dialog.metricSystem then
			prop.right := 165 * mm 
		else 
			prop.right := 104 * inch16 
		end 
		fnt.GetBounds(asc, dsc, w)
		prop.lead := 0
		prop.asc := asc
		prop.dsc := dsc
		prop.grid := 1
		prop.opts.val_ := {leftAdjust}
		prop.opts.mask := options
		prop.tabs.len_ := 0
		
		new(def)
		def.InitFromProp(prop)
		new(d)
		d.attr := def
		dir := d
		stdDir := d
	end Init
	
	proc Cleaner
	begin 
		globRd := nil
	end Cleaner
	
	proc GetRadixChar*(a: Attributes; tabIndex: integer): wchar 
	begin 
		return a.tabsData[tabIndex]
	end GetRadixChar
	
	proc SetRadixChar*(a: Attributes; tabIndex: integer; radixChar: wchar) 
	begin 
		a.tabsData[tabIndex] := radixChar
	end SetRadixChar
	
	proc SetRadixCharProp*(p: Prop; tabIndex: integer; radixChar: wchar) 
	begin 
		p.tabsData[tabIndex] := radixChar
	end SetRadixCharProp

begin
	Init
	Kernel.InstallCleaner(Cleaner)
(* CLOSE
	Kernel.RemoveCleaner(Cleaner) *) 
end Rulers
