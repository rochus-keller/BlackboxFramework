module Views
	(* project	= "BlackBox"
	   organization	= "www.oberon.ch"
	   contributors	= "Oberon microsystems"
	   version	= "System/Rsrc/About"
	   copyright	= "System/Rsrc/About"
	   license	= "Docu/BB-License"
	   changes	= "##=>
	   
	   - YYYYMMDD, nn, ...
	   ##<="
	   issues	= "##=>
	   
	   - fundamentally, using purely host-specific area-invalidation would be better, but that would be major change
	   ##<=" *)
	
	
	
	
	import SYSTEM, 
		Kernel, Log, Dialog, Files, Services, Fonts, Stores, Converters, Ports, Sequencers, Models
	
	const 
		// View.Background color
		transparent* = 0ff000000h
		
		// Views.CopyModel / Views.CopyOf shallow
		deep* = false
		shallow* = true
		
		// Update, UpdateIn rebuild
		keepFrames* = false
		rebuildFrames* = true
		
		// Deposit, QualifiedDeposit, Fetch w, h
		undefined* = 0
		
		// OldView, RegisterView ask
		dontAsk* = false
		ask* = true
		
		// method numbers (UNSAFE!)
		// copyFrom = 1;
		copyFromModelView = 7
		copyFromSimpleView = 8
		
		// Frame.state
		new_ = 0
		open = 1
		closed = 2
		
		maxN = 30 // max number of rects used to approximate a region
		
		minVersion = 0
		maxVersion = 0
		
		// actOp
		handler = 1
		restore = 2
		externalize = 3
		
		markBorderSize = 2
		
		clean* = Sequencers.clean
		notUndoable* = Sequencers.notUndoable
		invisible* = Sequencers.invisible
	
	
	type 
		
		// views
		
		View* = pointer to (* abstract *) record (Stores.Store) 
				context-: Models.Context // stable context # NIL
				//era: integer
				guard: integer // = TrapCount()+1 if view is addressee of ongoing broadcast
				bad: set 
			end 
		
		Alien* = pointer to (* limited *) record (View) 
				store-: Stores.Alien 
			end 
		
		Title* = array 64 of char
		
		TrapAlien = pointer to record (Stores.Store) end 
		
		
		// frames
		
		Frame* = pointer to (* abstract *) record (Ports.Frame) 
				l-, t-, r-, b-: integer // l < r, t < b
				view-: View // opened => view # NIL, view.context # NIL, view.seq # NIL
				front-, mark-: boolean
				state: byte
				x, y: integer // origin in coordinates of environment
				gx0, gy0: integer // global origin w/o local scrolling compensation
				sx, sy: integer // cumulated local sub-pixel scrolling compensation
				next, down, up, focus: Frame
				level: integer  // used for partial z-ordering
			end 
		
		
		Message* = (* abstract *) record 
				view-: View  // view # NIL
			end 
		
		NotifyMsg* = (* extensible *) record (Message) 
				id0*, id1*: integer
				opts*: set 
			end 
		
		NotifyHook = pointer to record (Dialog.NotifyHook) end 
		
		UpdateCachesMsg* = (* extensible *) record (Message) end 
		
		ScrollClassMsg* = record (Message) 
				allowBitmapScrolling*: boolean  // OUT, preset to FALSE
			end 
		
		
		// property messages
		
		PropMessage* = (* abstract *) record end 
		
		
		// controller messages
		
		CtrlMessage* = (* abstract *) record end 
		
		CtrlMsgHandler* = proc (op: integer; f, g: Frame; var msg: CtrlMessage; var mark, front, req: boolean)
		
		UpdateMsg = record (Message) 
				scroll, rebuild, all: boolean
				l, t, r, b, dx, dy: integer 
			end 
		
		
		Rect = record 
				v: View
				rebuild: boolean
				l, t, r, b: integer 
			end 
		
		Region = pointer to record 
				n: integer
				r: array maxN of Rect 
			end 
		
		RootFrame* = pointer to record (Frame) 
				flags-: set
				update: Region  // allocated lazily by SetRoot
			end 
		
		StdFrame = pointer to record (Frame) end 
		
		
		// view producer/consumer decoupling
		
		QueueElem = pointer to record 
				next: QueueElem
				view: View 
			end 
		
		GetSpecHook* = pointer to (* abstract *) record (Kernel.Hook) end 
		ViewHook* = pointer to (* abstract *) record (Kernel.Hook) end 
		MsgHook* = pointer to (* abstract *) record (Kernel.Hook) end 
	
	
	
	var 
		HandleCtrlMsg-: CtrlMsgHandler
		
		domainGuard: integer // = TrapCount()+1 if domain is addressee of ongoing domaincast
		
		actView: View
		actFrame: RootFrame
		actOp: integer
		
		copyModel: Models.Model // context for (View)CopyFrom; reset by TrapCleanup
		
		queue: record 
				len_: integer
				head, tail: QueueElem 
			end 
		
		getSpecHook: GetSpecHook
		viewHook: ViewHook
		msgHook: MsgHook
	
	
	proc Overwritten(v: View; mno: integer): boolean 
		var 
			base, actual: proc 
	begin 
		SYSTEM.GET(SYSTEM.TYP(View) - 4 * (mno + 1), base)
		SYSTEM.GET(SYSTEM.TYP(v) - 4 * (mno + 1), actual)
		return actual # base
	end Overwritten
	
	// Hooks
	
	proc (h: GetSpecHook) GetExtSpec*(s: Stores.Store; var loc: Files.Locator
		var name: Files.Name; var conv: Converters.Converter)  end // new abstract
	proc (h: GetSpecHook) GetIntSpec*(var loc: Files.Locator; var name: Files.Name
		var conv: Converters.Converter)  end // new abstract
	
	proc SetGetSpecHook*(h: GetSpecHook) 
	begin 
		getSpecHook := h
	end SetGetSpecHook
	
	proc (h: ViewHook) OldView*(loc: Files.Locator; name: Files.Name
		var conv: Converters.Converter): View  end // new abstract
	proc (h: ViewHook) Open*(s: View; title: array of char
		loc: Files.Locator; name: Files.Name; conv: Converters.Converter
		asTool, asAux, noResize, allowDuplicates, neverDirty: boolean)  end // new abstract
	proc (h: ViewHook) RegisterView*(s: View; loc: Files.Locator
		name: Files.Name; conv: Converters.Converter)  end // new abstract
	
	proc SetViewHook*(h: ViewHook) 
	begin 
		viewHook := h
	end SetViewHook
	
	proc (h: MsgHook) Omnicast*(var msg: ANYREC)  end // new abstract
	proc (h: MsgHook) RestoreDomain*(domain: Stores.Domain)  end // new abstract
	
	proc SetMsgHook*(h: MsgHook) 
	begin 
		msgHook := h
	end SetMsgHook
	
	
	// Model protocol
	
	proc (v: View) CopyFromSimpleView-(source: View)  end // new empty
	proc (v: View) CopyFromModelView-(source: View; model: Models.Model)  end // new empty
	
	proc (v: View) ThisModel*(): Models.Model  // new extensible
	begin 
		return nil
	end ThisModel
	
	
	// Store protocol
	
	proc (v: View) CopyFrom-(source: Stores.Store) 
		var 
			tm, fm: Models.Model
			c: Models.Context
	begin 
		tm := copyModel
		copyModel := nil
		with source: View do 
			v.era := source.era
			actView := nil
			if tm = nil then // if copyModel wasn't preset then use deep copy as default
				fm := source.ThisModel()
				if fm # nil then
					tm := Stores.CopyOf(fm)(Models.Model) 
				end  
			end 
			actView := v
			if Overwritten(v, copyFromModelView) then // new View
				assert(~Overwritten(v, copyFromSimpleView), 20)
				c := v.context
				v.CopyFromModelView(source, tm)
				assert(v.context = c, 60) 
			else  // old or simple View
				// IF tm # NIL THEN v.InitModel(tm) END
				c := v.context
				v.CopyFromSimpleView(source)
				assert(v.context = c, 60) 
			end  
		end 
	end CopyFrom
	
	proc (v: View) Internalize-(var rd: Stores.Reader)  // extensible
		var 
			thisVersion: integer
	begin 
		v.Internalize^(rd)
		if rd.cancelled then
			return  
		end 
		rd.ReadVersion(minVersion, maxVersion, thisVersion)
	end Internalize
	
	proc (v: View) Externalize-(var wr: Stores.Writer)  // extensible
	begin 
		v.Externalize^(wr)
		wr.WriteVersion(maxVersion)
	end Externalize
	
	
	// embedding protocol
	
	proc (v: View) InitContext*(context: Models.Context)  // new extensible
	begin 
		assert(context # nil, 21)
		assert((v.context = nil) or (v.context = context), 22)
		v.context := context
	end InitContext
	
	proc (v: View) GetBackground*(var color: Ports.Color)  end // new empty
	proc (v: View) ConsiderFocusRequestBy-(view: View)  end // new empty
	proc (v: View) Neutralize* end // new empty
	
	
	// Frame protocol
	
	proc (v: View) GetNewFrame*(var frame: Frame)  end // new empty
	proc (v: View) Restore*(f: Frame; l, t, r, b: integer)  end // new abstract
	proc (v: View) RestoreMarks*(f: Frame; l, t, r, b: integer)  end // new empty
	
	
	// handlers
	
	proc (v: View) HandleModelMsg-(var msg: Models.Message)  end // new empty
	proc (v: View) HandleViewMsg-(f: Frame; var msg: Message)  end // new empty
	proc (v: View) HandleCtrlMsg*(f: Frame; var msg: CtrlMessage; var focus: View)  end // new empty
	proc (v: View) HandlePropMsg-(var msg: PropMessage)  end // new empty
	
	
	// Alien
	
	proc (a: Alien) Externalize-(var wr: Stores.Writer) 
	begin 
		halt(100)
	end Externalize
	
	proc (a: Alien) Internalize-(var rd: Stores.Reader) 
	begin 
		halt(100)
	end Internalize
	
	proc (a: Alien) CopyFromSimpleView-(source: View) 
	begin 
		a.store := Stores.CopyOf(source(Alien).store)(Stores.Alien)
		Stores.Join(a, a.store)
	end CopyFromSimpleView
	
	proc (a: Alien) Restore*(f: Frame; l, t, r, b: integer) 
		var 
			u, w, h: integer
	begin 
		u := f.dot
		a.context.GetSize(w, h)
		f.DrawRect(0, 0, w, h, Ports.fill, Ports.grey25)
		f.DrawRect(0, 0, w, h, 2 * u, Ports.grey75)
		f.DrawLine(0, 0, w - u, h - u, u, Ports.grey75)
		f.DrawLine(w - u, 0, 0, h - u, u, Ports.grey75)
	end Restore
	
	
	// TrapAlien
	
	proc (v: TrapAlien) Internalize(var rd: Stores.Reader) 
	begin 
		v.Internalize^(rd)
		rd.TurnIntoAlien(3)
	end Internalize
	
	proc (v: TrapAlien) Externalize(var rd: Stores.Writer) 
	end Externalize
	
	proc (v: TrapAlien) CopyFrom(source: Stores.Store)  end // empty
	
	
	// Frame
	
	proc (f: Frame) Close*()  end // new empty
	
	
	// Rect, Region
	
	proc Union(var u: Rect; r: Rect) 
	begin 
		if r.v # u.v then
			u.v := nil 
		end 
		if r.rebuild then
			u.rebuild := true 
		end 
		if r.l < u.l then
			u.l := r.l 
		end 
		if r.t < u.t then
			u.t := r.t 
		end 
		if r.r > u.r then
			u.r := r.r 
		end 
		if r.b > u.b then
			u.b := r.b 
		end 
	end Union
	
	proc Add(rgn: Region; v: View; rebuild: boolean; gl, gt, gr, gb: integer) 
		// does not perfectly maintain invariant of non-overlapping approx rects ...
		var 
			q: Rect
			i, j, n: integer
			x: array maxN of boolean
	begin 
		q.v := v
		q.rebuild := rebuild
		q.l := gl
		q.t := gt
		q.r := gr
		q.b := gb
		n := rgn.n + 1
		i := 0
		while i < rgn.n do 
			x[i] := (gl < rgn.r[i].r) & (rgn.r[i].l < gr) & (gt < rgn.r[i].b) & (rgn.r[i].t < gb)
			if x[i] then
				Union(q, rgn.r[i])
				dec(n) 
			end 
			inc(i) 
		end 
		if n > maxN then
			// n = maxN + 1 -> merge q with arbitrarily picked rect and Add
			Union(q, rgn.r[maxN - 1])
			Add(rgn, v, q.rebuild, q.l, q.t, q.r, q.b) 
		else 
			i := 0
			while (i < rgn.n) & ~x[i] do 
				inc(i) 
			end 
			rgn.r[i] := q
			inc(i)
			while (i < rgn.n) & ~x[i] do 
				inc(i) 
			end 
			j := i
			while (i < rgn.n) & x[i] do 
				inc(i) 
			end 
			while i < rgn.n do  // ~x[i]
				rgn.r[j] := rgn.r[i]
				inc(j)
				inc(i)
				while (i < rgn.n) & x[i] do 
					inc(i) 
				end  
			end 
			rgn.n := n 
		end 
	end Add
	
	proc AddRect(root: RootFrame; f: Frame; l, t, r, b: integer; rebuild: boolean) 
		var 
			rl, rt, rr, rb: integer
			i: integer
	begin 
		inc(l, f.gx)
		inc(t, f.gy)
		inc(r, f.gx)
		inc(b, f.gy)
		rl := root.l + root.gx
		rt := root.t + root.gy
		rr := root.r + root.gx
		rb := root.b + root.gy
		if l < rl then
			l := rl 
		end 
		if t < rt then
			t := rt 
		end 
		if r > rr then
			r := rr 
		end 
		if b > rb then
			b := rb 
		end 
		if (l < r) & (t < b) then
			Add(root.update, f.view, rebuild, l, t, r, b)
			i := 0
			while (i < root.update.n) 
				& (~root.update.r[i].rebuild or (root.update.r[i].v # nil)) do 
				inc(i) 
			end 
			if i < root.update.n then
				Add(root.update, root.view, true, rl, rt, rr, rb) 
			end  
		end 
	end AddRect
	
	
	// miscellaneous
	
	proc RestoreDomain*(domain: Stores.Domain) 
	begin 
		assert(msgHook # nil, 100)
		msgHook.RestoreDomain(domain)
	end RestoreDomain
	
	proc MarkBorder*(host: Ports.Frame; view: View; l, t, r, b: integer) 
		var 
			s: integer
	begin 
		if view # nil then
			s := markBorderSize * host.dot
			host.MarkRect(l - s, t - s, r + s, b + s, s, Ports.dim50, Ports.show) 
		end 
	end MarkBorder
	
	
	
	// views
	
	proc SeqOf(v: View): Sequencers.Sequencer 
		var  // c: Models.Context;
			d: Stores.Domain
			seq: Sequencers.Sequencer
			any: ANYPTR
	begin 
		d := v.Domain()
		seq := nil
		if d # nil then
			any := d.GetSequencer()
			if (any # nil) & (any is Sequencers.Sequencer) then
				seq := any(Sequencers.Sequencer) 
			end  
		end 
		return seq
	end SeqOf
	
	
	proc Era*(v: View): integer 
	// * pre: v # NIL
	(* post:
	   v.ThisModel() # NIL
	   in-synch(v) iff Era(v) = Models.Era(v.ThisModel()) *)
	
	begin 
		assert(v # nil, 20)
		return v.era
	end Era
	
	proc BeginScript*(v: View; name: Stores.OpName; var script: Stores.Operation) 
		// * pre: v # NIL
		// post: (script # NIL) iff (v.seq # NIL)
		var 
			seq: Sequencers.Sequencer
	begin 
		assert(v # nil, 20)
		seq := SeqOf(v)
		if seq # nil then
			seq.BeginScript(name, script) 
		else 
			script := nil 
		end 
	end BeginScript
	
	proc Do*(v: View; name: Stores.OpName; op: Stores.Operation) 
		// pre: v # NIL, op # NIL, ~op.inUse
		var 
			seq: Sequencers.Sequencer
	begin 
		assert(v # nil, 20) // ASSERT(~op.inUse, 22);
		assert(op # nil, 21)
		seq := SeqOf(v)
		if seq # nil then
			seq.Do(v, name, op) 
		else 
			op.Do 
		end 
	end Do
	
	proc LastOp*(v: View): Stores.Operation 
		// pre: v # NIL
		var 
			seq: Sequencers.Sequencer
	begin 
		assert(v # nil, 20)
		seq := SeqOf(v)
		if seq # nil then
			return seq.LastOp(v) 
		else 
			return nil 
		end 
	end LastOp
	
	proc Bunch*(v: View) 
		// pre: v # NIL
		var 
			seq: Sequencers.Sequencer
	begin 
		assert(v # nil, 20)
		seq := SeqOf(v)
		assert(seq # nil, 21)
		seq.Bunch(v)
	end Bunch
	
	proc StopBunching*(v: View) 
		// pre: v # NIL
		var 
			seq: Sequencers.Sequencer
	begin 
		assert(v # nil, 20)
		seq := SeqOf(v)
		if seq # nil then
			seq.StopBunching 
		end 
	end StopBunching
	
	proc EndScript*(v: View; script: Stores.Operation) 
		// pre: (script # NIL) iff (v.seq # NIL)
		var 
			seq: Sequencers.Sequencer
	begin 
		assert(v # nil, 20)
		seq := SeqOf(v)
		if seq # nil then
			assert(script # nil, 21)
			seq.EndScript(script) 
		else 
			assert(script = nil, 22) 
		end 
	end EndScript
	
	
	proc BeginModification*(type_: integer; v: View) 
		var 
			seq: Sequencers.Sequencer
	begin 
		assert(v # nil, 20)
		seq := SeqOf(v)
		if seq # nil then
			seq.BeginModification(type_, v) 
		end 
	end BeginModification
	
	proc EndModification*(type_: integer; v: View) 
		var 
			seq: Sequencers.Sequencer
	begin 
		assert(v # nil, 20)
		seq := SeqOf(v)
		if seq # nil then
			seq.EndModification(type_, v) 
		end 
	end EndModification
	
	proc SetDirty*(v: View) 
		var 
			seq: Sequencers.Sequencer
	begin 
		assert(v # nil, 20)
		seq := SeqOf(v)
		if seq # nil then
			seq.SetDirty(true) 
		end 
	end SetDirty
	
	
	proc Domaincast*(domain: Stores.Domain; var msg: Message) 
		var 
			g: integer
			seq: ANYPTR
	begin 
		if domain # nil then
			seq := domain.GetSequencer()
			if seq # nil then
				msg.view := nil
				g := Kernel.trapCount + 1
				if domainGuard > 0 then
					assert(domainGuard # g, 20) 
				end 
				domainGuard := g
				seq(Sequencers.Sequencer).Handle(msg)
				domainGuard := 0 
			end  
		end 
	end Domaincast
	
	proc Broadcast*(v: View; var msg: Message) 
		var 
			seq: Sequencers.Sequencer
			g: integer
	begin 
		assert(v # nil, 20)
		msg.view := v
		seq := SeqOf(v)
		if seq # nil then
			g := Kernel.trapCount + 1
			if v.guard > 0 then
				assert(v.guard # g, 21) 
			end 
			v.guard := g
			seq.Handle(msg)
			v.guard := 0 
		end 
	end Broadcast
	
	
	proc Update*(v: View; rebuild: boolean) 
		var 
			upd: UpdateMsg
	begin 
		assert(v # nil, 20)
		upd.scroll := false
		upd.rebuild := rebuild
		upd.all := true
		Broadcast(v, upd)
	end Update
	
	proc UpdateIn*(v: View; l, t, r, b: integer; rebuild: boolean) 
		var 
			upd: UpdateMsg
	begin 
		assert(v # nil, 20)
		upd.scroll := false
		upd.rebuild := rebuild
		upd.all := false
		upd.l := l
		upd.t := t
		upd.r := r
		upd.b := b
		Broadcast(v, upd)
	end UpdateIn
	
	proc Scroll*(v: View; dx, dy: integer) 
		var 
			scroll: UpdateMsg
	begin 
		assert(v # nil, 20)
		assert(v.Domain() # nil, 21)
		RestoreDomain(v.Domain())
		scroll.scroll := true
		scroll.dx := dx
		scroll.dy := dy
		Broadcast(v, scroll)
	end Scroll
	
	proc CopyOf*(v: View; shallow: boolean): View 
		var 
			w, a: View
			op: integer
			b: Alien
	begin 
		assert(v # nil, 20)
		if ~(handler in v.bad) then
			a := actView
			op := actOp
			actView := nil
			actOp := handler
			if shallow then
				copyModel := v.ThisModel() 
			end 
			actView := v
			w := Stores.CopyOf(v)(View)
			actView := a
			actOp := op 
		else 
			new(b)
			w := b
			w.bad := {handler..externalize} 
		end 
		if shallow then
			Stores.Join(w, v) 
		end 
		return w
	end CopyOf
	
	proc CopyWithNewModel*(v: View; m: Models.Model): View 
		var 
			w, a: View
			op: integer
			b: Alien
			fm: Models.Model
	begin 
		assert(v # nil, 20)
		fm := v.ThisModel()
		assert(fm # nil, 21)
		assert(m # nil, 22)
		assert(Services.SameType(m, fm), 23)
		if ~(handler in v.bad) then
			a := actView
			op := actOp
			actView := v
			actOp := handler
			copyModel := m
			w := Stores.CopyOf(v)(View)
			actView := a
			actOp := op 
		else 
			new(b)
			w := b
			w.bad := {handler..externalize} 
		end 
		return w
	end CopyWithNewModel
	
	proc ReadView*(var rd: Stores.Reader; var v: View) 
		var 
			st: Stores.Store
			a: Alien
	begin 
		rd.ReadStore(st)
		if st = nil then
			v := nil 
		elsif st is Stores.Alien then 
			new(a)
			a.store := st(Stores.Alien)
			Stores.Join(a, a.store)
			v := a 
		else 
			v := st(View) 
		end 
	end ReadView
	
	proc WriteView*(var wr: Stores.Writer; v: View) 
		var 
			a: TrapAlien
			av: View
			op: integer
	begin 
		if v = nil then
			wr.WriteStore(v) 
		elsif externalize in v.bad then 
			new(a)
			wr.WriteStore(a) 
		elsif v is Alien then 
			wr.WriteStore(v(Alien).store) 
		else 
			av := actView
			op := actOp
			actView := v
			actOp := externalize
			wr.WriteStore(v)
			actView := av
			actOp := op 
		end 
	end WriteView
	
	
	// frames
	
	proc SetClip(f: Frame; l, t, r, b: integer) 
		var 
			u: integer
	begin 
		assert(f.rider # nil, 20)
		assert(l <= r, 21)
		assert(t <= b, 22)
		u := f.unit
		f.rider.SetRect((l + f.gx) div u, (t + f.gy) div u, (r + f.gx) div u, (b + f.gy) div u)
		f.l := l
		f.t := t
		f.r := r
		f.b := b
	end SetClip
	
	proc Close(f: Frame) 
	begin 
		f.Close
		f.state := closed
		f.up := nil
		f.down := nil
		f.next := nil
		f.view := nil
		f.ConnectTo(nil)
	end Close
	
	proc AdaptFrameTo(f: Frame; orgX, orgY: integer) 
		var 
			g, p, q: Frame
			port: Ports.Port
			w, h, pl, pt, pr, pb, gl, gt, gr, gb, gx, gy: integer
	begin 
		// pre: environment (i.e. parent frame / port) has already been set up
		assert(f.view # nil, 20)
		assert(f.view.context # nil, 21)
		f.x := orgX // set new origin
		f.y := orgY
		g := f.up
		if g # nil then // parent frame is environment
			f.gx0 := g.gx + orgX
			f.gy0 := g.gy + orgY
			f.SetOffset(f.gx0 - f.sx, f.gy0 - f.sy)
			pl := g.gx + g.l
			pt := g.gy + g.t
			pr := g.gx + g.r
			pb := g.gy + g.b 
		else  // port is environment
			f.gx0 := orgX
			f.gy0 := orgY
			f.SetOffset(f.gx0 - f.sx, f.gy0 - f.sy)
			port := f.rider.Base()
			port.GetSize(w, h)
			pl := 0
			pt := 0
			pr := w * f.unit
			pb := h * f.unit 
		end 
		// (pl, pt, pr, pb) is parent clipping rectangle, in global coordinates, and in units
		gx := f.gx
		gy := f.gy
		f.view.context.GetSize(w, h)
		gl := gx
		gt := gy
		gr := gx + w
		gb := gy + h
		// (gl, gt, gr, gb) is desired clipping rectangle, in global coordinates, and in units
		if gl < pl then
			gl := pl 
		end 
		if gt < pt then
			gt := pt 
		end 
		if gr > pr then
			gr := pr 
		end 
		if gb > pb then
			gb := pb 
		end 
		if (gl >= gr) or (gt >= gb) then
			gr := gl
			gb := gt 
		end 
		SetClip(f, gl - gx + f.sx, gt - gy + f.sy, gr - gx + f.sx, gb - gy + f.sy)
		// (f.l, f.t, f.r, f.b) is final clipping rectangle, in local coordinates, and in units
		g := f.down
		f.down := nil
		p := nil
		while g # nil do  // adapt child frames
			q := g.next
			g.next := nil
			AdaptFrameTo(g, g.x, g.y)
			if g.l = g.r then // empty child frame: remove
				Close(g) 
			else  // insert in new frame list
				if p = nil then
					f.down := g 
				else 
					p.next := g 
				end 
				p := g 
			end 
			g := q 
		end 
	// post: frame is set; child frames are set, nonempty, and clipped to frame
	end AdaptFrameTo
	
	proc SetRoot*(root: RootFrame; view: View; front: boolean; flags: set) 
	begin 
		assert(root # nil, 20)
		assert(root.rider # nil, 21)
		assert(view # nil, 22)
		assert(view.context # nil, 23)
		assert(view.Domain() # nil, 24)
		assert(root.state in {new_, open}, 25)
		root.view := view
		root.front := front
		root.mark := true
		root.flags := flags
		root.state := open
		if root.update = nil then
			new(root.update)
			root.update.n := 0 
		end 
	end SetRoot
	
	proc AdaptRoot*(root: RootFrame) 
	begin 
		assert(root # nil, 20)
		assert(root.state = open, 21)
		AdaptFrameTo(root, root.x, root.y)
	end AdaptRoot
	
	proc UpdateRoot*(root: RootFrame; l, t, r, b: integer; rebuild: boolean) 
	begin 
		assert(root # nil, 20)
		assert(root.state = open, 21)
		AddRect(root, root, l, t, r, b, rebuild)
	end UpdateRoot
	
	proc RootOf*(f: Frame): RootFrame 
	begin 
		assert(f # nil, 20)
		assert(f.state = open, 21)
		while f.up # nil do 
			f := f.up 
		end 
		return f(RootFrame)
	end RootOf
	
	proc HostOf*(f: Frame): Frame 
	begin 
		assert(f # nil, 20)
		return f.up
	end HostOf
	
	proc IsPrinterFrame*(f: Frame): boolean 
		var 
			p: Ports.Port
	begin 
		assert(f # nil, 20)
		assert(f.state = open, 21)
		p := f.rider.Base()
		return Ports.IsPrinterPort(p)
	end IsPrinterFrame
	
	proc InstallFrame*(host: Frame; view: View; x, y, level: integer; focus: boolean) 
		var 
			e, f, g: Frame
			w, h, l, t, r, b: integer
			m: Models.Model
			std: StdFrame
			msg: UpdateCachesMsg
			a: View
			op: integer
	begin 
		assert(host # nil, 20)
		assert(host.state = open, 21)
		assert(view # nil, 22)
		assert(view.context # nil, 23)
		assert(view.Domain() # nil, 24)
		e := nil
		g := host.down
		while (g # nil) & (g.view # view) do 
			e := g
			g := g.next 
		end 
		if g = nil then // frame for view not yet in child frame list
			view.context.GetSize(w, h)
			if w > max(integer) div 2 then
				w := max(integer) div 2 
			end 
			if h > max(integer) div 2 then
				h := max(integer) div 2 
			end 
			l := x
			t := y
			r := x + w
			b := y + h
			// (l, t, r, b) is child frame rectangle, in local coordinates, and in units
			if (l < host.r) & (t < host.b) & (r > host.l) & (b > host.t) then // visible
				g := nil
				view.GetNewFrame(g)
				if g = nil then
					new(std)
					g := std 
				end 
				assert(~(g is RootFrame), 100)
				e := nil
				f := host.down
				while (f # nil) & (f.level <= level) do 
					e := f
					f := f.next 
				end 
				if e = nil then
					g.next := host.down
					host.down := g 
				else 
					g.next := e.next
					e.next := g 
				end 
				g.down := nil
				g.up := host
				g.level := level
				g.view := view
				g.ConnectTo(host.rider.Base())
				g.state := open
				AdaptFrameTo(g, x, y)
				if ~(handler in view.bad) then
					a := actView
					op := actOp
					actView := view
					actOp := handler
					view.HandleViewMsg(g, msg)
					actView := a
					actOp := op 
				end 
				m := view.ThisModel()
				if m # nil then
					view.era := Models.Era(m) 
				end  
			end  
		else 
			if g.level # level then // adapt to modified z-order
				if e = nil then
					host.down := g.next 
				else 
					e.next := g.next 
				end 
				e := nil
				f := host.down
				while (f # nil) & (f.level <= level) do 
					e := f
					f := f.next 
				end 
				if e = nil then
					g.next := host.down
					host.down := g 
				else 
					g.next := e.next
					e.next := g 
				end 
				g.level := level 
			end 
			AdaptFrameTo(g, x, y)  // may close g, leaving g.state = closed
		// possibly optimize: don't call Adapt if x=g.x, y=g.y, "host.era=g.era"
		end 
		if (g # nil) & (g.state = open) then
			if focus then
				g.front := host.front
				g.mark := host.mark 
			else 
				g.front := false
				g.mark := false 
			end  
		end 
	end InstallFrame
	
	proc RemoveAll(f: Frame) 
		var 
			g, p: Frame
	begin 
		g := f.down
		while g # nil do 
			p := g.next
			RemoveAll(g)
			Close(g)
			g := p 
		end 
		f.down := nil
	end RemoveAll
	
	proc RemoveFrame*(host, f: Frame) 
		var 
			g, h: Frame
	begin 
		assert(host # nil, 20)
		assert(host.state = open, 21)
		assert(f # nil, 22)
		assert(f.up = host, 23)
		g := host.down
		h := nil
		while (g # nil) & (g # f) do 
			h := g
			g := g.next 
		end 
		assert(g = f, 24)
		if h = nil then
			host.down := f.next 
		else 
			h.next := f.next 
		end 
		RemoveAll(f)
		Close(f)
	end RemoveFrame
	
	proc RemoveFrames*(host: Frame; l, t, r, b: integer) 
		var 
			f, g: Frame
			gl, gt, gr, gb: integer
	begin 
		assert(host # nil, 20)
		assert(host.state = open, 21)
		if l < host.l then
			l := host.l 
		end 
		if t < host.t then
			t := host.t 
		end 
		if r > host.r then
			r := host.r 
		end 
		if b > host.b then
			b := host.b 
		end 
		if (l < r) & (t < b) then
			gl := l + host.gx
			gt := t + host.gy
			gr := r + host.gx
			gb := b + host.gy
			f := host.down
			while f # nil do 
				g := f
				f := f.next
				if (gl < g.r + g.gx) & (g.l + g.gx < gr) & (gt < g.b + g.gy) & (g.t + g.gy < gb) then
					RemoveFrame(host, g) 
				end  
			end  
		end 
	end RemoveFrames
	
	proc ThisFrame*(host: Frame; view: View): Frame 
		var 
			g: Frame
	begin 
		assert(host # nil, 20)
		assert(host.state = open, 21)
		g := host.down
		while (g # nil) & (g.view # view) do 
			g := g.next 
		end 
		return g
	end ThisFrame
	
	proc FrameAt*(host: Frame; x, y: integer): Frame 
		// return frontmost sub-frame of host that contains (x, y)
		var 
			g, h: Frame
	begin 
		assert(host # nil, 20)
		assert(host.state = open, 21)
		g := host.down
		h := nil
		inc(x, host.gx)
		inc(y, host.gy)
		while g # nil do 
			if (g.gx + g.l <= x) & (x < g.gx + g.r) & (g.gy + g.t <= y) & (y < g.gy + g.b) then
				h := g 
			end 
			g := g.next 
		end 
		return h
	end FrameAt
	
	proc ShiftFrames(f: Frame; dx, dy: integer) 
		var 
			g, h: Frame
	begin 
		g := f.down
		while g # nil do 
			h := g
			g := g.next
			AdaptFrameTo(h, h.x + dx, h.y + dy)
			if h.l = h.r then
				RemoveFrame(f, h) 
			end  
		end 
	end ShiftFrames
	
	proc UpdateExposedArea(f: Frame; dx, dy: integer) 
		var 
			root: RootFrame
	begin 
		root := RootOf(f)
		if dy > 0 then
			AddRect(root, f, f.l, f.t, f.r, f.t + dy, keepFrames)
			if dx > 0 then
				AddRect(root, f, f.l, f.t + dy, f.l + dx, f.b, keepFrames) 
			else 
				AddRect(root, f, f.r + dx, f.t + dy, f.r, f.b, keepFrames) 
			end  
		else 
			AddRect(root, f, f.l, f.b + dy, f.r, f.b, keepFrames)
			if dx > 0 then
				AddRect(root, f, f.l, f.t, f.l + dx, f.b + dy, keepFrames) 
			else 
				AddRect(root, f, f.r + dx, f.t, f.r, f.b + dy, keepFrames) 
			end  
		end 
	end UpdateExposedArea
	
	proc ScrollFrame(f: Frame; dx, dy: integer) 
		var 
			g: Frame
			u, dx0, dy0: integer
			bitmapScrolling: boolean
			msg: ScrollClassMsg
	begin 
		g := f.up
		bitmapScrolling := true
		if (g # nil) then
			while bitmapScrolling & (g.up # nil) do 
				msg.allowBitmapScrolling := false
				g.view.HandleViewMsg(g, msg)
				bitmapScrolling := bitmapScrolling & msg.allowBitmapScrolling
				g := g.up 
			end  
		end 
		if bitmapScrolling then
			u := f.unit
			dx0 := dx
			dy0 := dy
			inc(dx, f.sx)
			inc(dy, f.sy)
			dec(f.l, f.sx)
			dec(f.t, f.sy)
			dec(f.r, f.sx)
			dec(f.b, f.sy)
			f.sx := dx mod u
			f.sy := dy mod u
			dec(dx, f.sx)
			dec(dy, f.sy)
			inc(f.l, f.sx)
			inc(f.t, f.sy)
			inc(f.r, f.sx)
			inc(f.b, f.sy)
			f.SetOffset(f.gx0 - f.sx, f.gy0 - f.sy)
			ShiftFrames(f, dx0, dy0)
			f.Scroll(dx, dy)
			UpdateExposedArea(f, dx, dy) 
		else 
			AddRect(RootOf(f), f, f.l, f.t, f.r, f.b, rebuildFrames) 
		end 
	end ScrollFrame
	
	proc BroadcastModelMsg*(f: Frame; var msg: Models.Message) 
		var 
			v, a: View
			send: boolean
			op: integer
	begin 
		assert(f # nil, 20)
		assert(f.state = open, 21)
		v := f.view
		if ~(handler in v.bad) then
			a := actView
			op := actOp
			actView := v
			actOp := handler
			if msg.model # nil then
				if (msg.model = v.ThisModel()) & (msg.era > v.era) then
					send := (msg.era - v.era = 1)
					v.era := msg.era
					if ~send then
						Log.synch := false
						halt(100) 
					end  
				else 
					send := false 
				end  
			else 
				send := true 
			end 
			if send then
				with msg: Models.NeutralizeMsg do 
					v.Neutralize 
				else 
					v.HandleModelMsg(msg) 
				end  
			end 
			actView := a
			actOp := op 
		end 
		f := f.down
		while f # nil do 
			BroadcastModelMsg(f, msg)
			f := f.next 
		end 
	end BroadcastModelMsg
	
	proc HandleUpdateMsg(f: Frame; var msg: UpdateMsg) 
		var 
			root: RootFrame
			g: Frame
			l, t, r, b, dx, dy: integer
	begin 
		root := RootOf(f)
		if msg.scroll then
			if root.update.n = 0 then
				ScrollFrame(f, msg.dx, msg.dy) 
			else 
				AddRect(root, f, f.l, f.t, f.r, f.b, msg.rebuild) 
			end  
		else 
			if msg.all then
				if f # root then
					g := f.up 
				else 
					g := root 
				end 
				dx := f.gx - g.gx
				dy := f.gy - g.gy
				AddRect(root, g, f.l + dx, f.t + dy, f.r + dx, f.b + dy, msg.rebuild) 
			else 
				l := msg.l
				t := msg.t
				r := msg.r
				b := msg.b
				if l < f.l then
					l := f.l 
				end 
				if t < f.t then
					t := f.t 
				end 
				if r > f.r then
					r := f.r 
				end 
				if b > f.b then
					b := f.b 
				end 
				AddRect(root, f, l, t, r, b, msg.rebuild) 
			end  
		end 
	end HandleUpdateMsg
	
	proc BroadcastViewMsg*(f: Frame; var msg: Message) 
		var 
			v, a: View
			op: integer
	begin 
		assert(f # nil, 20)
		assert(f.state = open, 21)
		v := f.view
		if (msg.view = v) or (msg.view = nil) then
			with msg: UpdateMsg do 
				HandleUpdateMsg(f, msg) 
			else 
				if ~(handler in v.bad) then
					a := actView
					op := actOp
					actView := v
					actOp := handler
					v.HandleViewMsg(f, msg)
					actView := a
					actOp := op 
				end  
			end  
		end 
		if msg.view # v then
			f := f.down
			while f # nil do 
				BroadcastViewMsg(f, msg)
				f := f.next 
			end  
		end 
	end BroadcastViewMsg
	
	proc ForwardCtrlMsg*(f: Frame; var msg: CtrlMessage) 
		const 
			pre = 0
			translate = 1
			backoff = 2
			final = 3
		var 
			v, focus, a: View
			g, h: Frame
			op: integer
			req: boolean
	begin 
		assert(f # nil, 20)
		assert(f.state = open, 21)
		v := f.view
		focus := nil
		g := f.up
		req := false
		HandleCtrlMsg(pre, f, g, msg, f.mark, f.front, req)
		if ~(handler in v.bad) then
			a := actView
			op := actOp
			actView := v
			actOp := handler
			v.HandleCtrlMsg(f, msg, focus)
			actView := a
			actOp := op 
		end 
		if focus # nil then // propagate msg to another view
			if (f.focus # nil) & (f.focus.view = focus) then // cache hit
				h := f.focus 
			else  // cache miss
				h := f.down
				while (h # nil) & (h.view # focus) do 
					h := h.next 
				end  
			end 
			if h # nil then
				HandleCtrlMsg(translate, f, h, msg, f.mark, f.front, req)
				f.focus := h
				ForwardCtrlMsg(h, msg)
				HandleCtrlMsg(backoff, f, g, msg, f.mark, f.front, req) 
			end  
		else 
			HandleCtrlMsg(final, f, g, msg, f.mark, f.front, req) 
		end 
		if req & (g # nil) then
			g.view.ConsiderFocusRequestBy(f.view) 
		end 
	end ForwardCtrlMsg
	
	
	proc RestoreFrame(f: Frame; l, t, r, b: integer) 
		var 
			rd: Ports.Rider
			g: Frame
			v, a: View
			op: integer
			u, w, h, cl, ct, cr, cb, dx, dy: integer
			col: Ports.Color
	begin 
		if l < f.l then
			l := f.l 
		end 
		if t < f.t then
			t := f.t 
		end 
		if r > f.r then
			r := f.r 
		end 
		if b > f.b then
			b := f.b 
		end 
		if (l < r) & (t < b) then // non-empty rectangle to be restored
			v := f.view
			rd := f.rider
			u := f.unit
			rd.GetRect(cl, ct, cr, cb) // save clip rectangle
			rd.SetRect((f.gx + l) div u, (f.gy + t) div u, (f.gx + r) div u, (f.gy + b) div u)
			if ~(restore in v.bad) then
				a := actView
				op := actOp
				actView := v
				actOp := restore
				col := transparent
				v.GetBackground(col)
				if col # transparent then
					f.DrawRect(l, t, r, b, Ports.fill, col) 
				end 
				v.Restore(f, l, t, r, b)
				g := f.down
				while g # nil do  // loop over all subframes to handle overlaps
					dx := f.gx - g.gx
					dy := f.gy - g.gy
					RestoreFrame(g, l + dx, t + dy, r + dx, b + dy)
					g := g.next 
				end 
				v.RestoreMarks(f, l, t, r, b)
				actView := a
				actOp := op 
			end 
			if v.bad # {} then
				if externalize in v.bad then
					u := f.dot
					v.context.GetSize(w, h)
					f.DrawLine(0, 0, w - u, h - u, u, Ports.grey75)
					f.DrawLine(w - u, 0, 0, h - u, u, Ports.grey75) 
				end 
				f.MarkRect(l, t, r, b, Ports.fill, Ports.dim25, Ports.show) 
			end 
			rd.SetRect(cl, ct, cr, cb)  // restore current clip rectangle
		end 
	end RestoreFrame
	
	proc RestoreRoot*(root: RootFrame; l, t, r, b: integer) 
		var 
			port: Ports.Port
			rd: Ports.Rider
			u, gl, gt, gr, gb: integer
			col: Ports.Color
	begin 
		assert(root # nil, 20)
		assert(root.state = open, 21)
		assert(root.update.n = 0, 22)
		if l < root.l then
			l := root.l 
		end 
		if t < root.t then
			t := root.t 
		end 
		if r > root.r then
			r := root.r 
		end 
		if b > root.b then
			b := root.b 
		end 
		if (l < r) & (t < b) then
			u := root.unit
			gl := l + root.gx
			gt := t + root.gy
			gr := r + root.gx
			gb := b + root.gy
			rd := root.rider
			port := rd.Base()
			actFrame := root
			if ~IsPrinterFrame(root) then
				port.OpenBuffer(gl div u, gt div u, gr div u, gb div u) 
			end 
			col := transparent
			root.view.GetBackground(col)
			assert(col # transparent, 100)
			RestoreFrame(root, l, t, r, b)
			if ~IsPrinterFrame(root) then
				port.CloseBuffer 
			end 
			actFrame := nil 
		end 
	end RestoreRoot
	
	proc ThisCand(f: Frame; v: View): Frame 
		// find frame g with g.view = v
		var 
			g: Frame
	begin 
		while (f # nil) & (f.view # v) do 
			g := ThisCand(f.down, v)
			if g # nil then
				f := g 
			else 
				f := f.next 
			end  
		end 
		return f
	end ThisCand
	
	proc ValidateRoot*(root: RootFrame) 
		var 
			rgn: Region
			f: Frame
			v: View
			i, n: integer
	begin 
		assert(root # nil, 20)
		assert(root.state = open, 21)
		rgn := root.update
		n := rgn.n
		rgn.n := 0
		i := 0
		while i < n do 
			if rgn.r[i].rebuild then
				v := rgn.r[i].v
				if v # nil then
					f := ThisCand(root, v) 
				else 
					f := nil 
				end 
				if f = nil then
					f := root 
				end 
				RemoveFrames(f, rgn.r[i].l - f.gx, rgn.r[i].t - f.gy, rgn.r[i].r - f.gx, rgn.r[i].b - f.gy) 
			end 
			inc(i) 
		end 
		i := 0
		while i < n do 
			RestoreRoot(root, rgn.r[i].l - root.gx, rgn.r[i].t - root.gy, rgn.r[i].r - root.gx, rgn.r[i].b - root.gy)
			inc(i) 
		end 
	end ValidateRoot
	
	proc MarkBordersIn(f: Frame) 
		var 
			g: Frame
			w, h: integer
	begin 
		g := f.down
		while g # nil do 
			g.view.context.GetSize(w, h)
			MarkBorder(f, g.view, g.x, g.y, g.x + w, g.y + h)
			MarkBordersIn(g)
			g := g.next 
		end 
	end MarkBordersIn
	
	proc MarkBorders*(root: RootFrame) 
	begin 
		MarkBordersIn(root)
	end MarkBorders
	
	proc ReadFont*(var rd: Stores.Reader; var f: Fonts.Font) 
		var 
			version: integer
			fingerprint, size_: integer
			typeface: Fonts.Typeface
			style: set
			weight: integer
	begin 
		rd.ReadVersion(0, 0, version)
		rd.ReadInt(fingerprint)
		rd.ReadXString(typeface)
		rd.ReadInt(size_)
		rd.ReadSet(style)
		rd.ReadXInt(weight)
		f := Fonts.dir.This(typeface, size_, style, weight)
		assert(f # nil, 60)
		if f.IsAlien() then
			Stores.Report("#System:AlienFont", typeface, "", "") 
		end 
	end ReadFont
	
	proc WriteFont*(var wr: Stores.Writer; f: Fonts.Font) 
	begin 
		assert(f # nil, 20)
		wr.WriteVersion(0)
		wr.WriteInt(0)
		wr.WriteXString(f.typeface)
		wr.WriteInt(f.size_)
		wr.WriteSet(f.style)
		wr.WriteXInt(f.weight)
	end WriteFont
	
	
	// view/file interaction
	
	proc Old*(ask: boolean
		var loc: Files.Locator; var name: Files.Name; var conv: Converters.Converter): View 
		var 
			v: View
	begin 
		assert(ask or (loc # nil), 20)
		assert(ask or (name # ""), 21)
		if ask then
			assert(getSpecHook # nil, 101)
			getSpecHook.GetIntSpec(loc, name, conv) 
		end 
		if (loc # nil) & (name # "") then
			assert(viewHook # nil, 100)
			v := viewHook.OldView(loc, name, conv) 
		else 
			v := nil 
		end 
		return v
	end Old
	
	proc OldView*(loc: Files.Locator; name: Files.Name): View 
		var 
			conv: Converters.Converter
	begin 
		conv := nil
		return Old(dontAsk, loc, name, conv)
	end OldView
	
	proc Register*(view: View; ask: boolean
		var loc: Files.Locator; var name: Files.Name; var conv: Converters.Converter; var res: integer) 
	begin 
		assert(viewHook # nil, 100)
		assert(getSpecHook # nil, 101)
		assert(view # nil, 20)
		assert(ask or (loc # nil), 22)
		assert(ask or (name # ""), 23)
		if ask or (loc = nil) or (name = "") or (loc.res = 77) then
			getSpecHook.GetExtSpec(view, loc, name, conv) 
		end 
		if (loc # nil) & (name # "") then
			viewHook.RegisterView(view, loc, name, conv)
			res := loc.res 
		else 
			res := 7 
		end 
	end Register
	
	proc RegisterView*(view: View; loc: Files.Locator; name: Files.Name) 
		var 
			res: integer
			conv: Converters.Converter
	begin 
		conv := nil
		Register(view, dontAsk, loc, name, conv, res)
	end RegisterView
	
	// direct view opening
	
	proc Open*(view: View; loc: Files.Locator; name: Files.Name; conv: Converters.Converter) 
	begin 
		assert(view # nil, 20)
		assert((loc = nil) = (name = ""), 21)
		assert(viewHook # nil, 100)
		viewHook.Open(view, name, loc, name, conv, false, false, false, false, false)
	end Open
	
	proc OpenView*(view: View) 
	begin 
		assert(view # nil, 20)
		Open(view, nil, "", nil)
	end OpenView
	
	proc OpenAux*(view: View; title: Title) 
	begin 
		assert(view # nil, 20)
		assert(viewHook # nil, 100)
		if title = "" then
			title := "#System:untitled" 
		end 
		viewHook.Open(view, title, nil, "", nil, false, true, false, true, true)
	end OpenAux
	
	
	// view producer/consumer decoupling
	
	proc Deposit*(view: View) 
		var 
			q: QueueElem
	begin 
		assert(view # nil, 20)
		new(q)
		q.view := view
		if queue.head = nil then
			queue.head := q 
		else 
			queue.tail.next := q 
		end 
		queue.tail := q
		inc(queue.len_)
	end Deposit
	
	proc Fetch*(var view: View) 
		var 
			q: QueueElem
	begin 
		q := queue.head
		assert(q # nil, 20)
		dec(queue.len_)
		queue.head := q.next
		if queue.head = nil then
			queue.tail := nil 
		end 
		view := q.view
	end Fetch
	
	proc Available*(): integer 
	begin 
		return queue.len_
	end Available
	
	proc ClearQueue*
	begin 
		queue.len_ := 0
		queue.head := nil
		queue.tail := nil
		actView := nil // HACK! prevents invalidation of view due to trap in Dialog.Call
	end ClearQueue
	
	
	// attach controller framework
	
	proc InitCtrl*(p: CtrlMsgHandler) 
	begin 
		assert(HandleCtrlMsg = nil, 20)
		HandleCtrlMsg := p
	end InitCtrl
	
	proc (h: NotifyHook) Notify(id0, id1: integer; opts: set) 
		var 
			msg: NotifyMsg
	begin 
		assert(msgHook # nil, 100)
		msg.id0 := id0
		msg.id1 := id1
		msg.opts := opts
		msgHook.Omnicast(msg)
	end Notify
	
	proc Omnicast*(var msg: ANYREC) 
	begin 
		msgHook.Omnicast(msg)
	end Omnicast
	
	proc HandlePropMsg*(v: View; var msg: PropMessage) 
		var 
			a: View
			op: integer
	begin 
		if ~(handler in v.bad) then
			a := actView
			op := actOp
			actView := v
			actOp := handler
			v.HandlePropMsg(msg)
			actView := a
			actOp := op 
		end 
	end HandlePropMsg
	
	
	// view invalidation
	
	proc IsInvalid*(v: View): boolean 
	begin 
		return v.bad # {}
	end IsInvalid
	
	proc RevalidateView*(v: View) 
	begin 
		v.bad := {}
		Update(v, keepFrames)
	end RevalidateView
	
	proc TrapCleanup
	begin 
		copyModel := nil
		if actView # nil then
			incl(actView.bad, actOp)
			if actFrame # nil then
				UpdateRoot(actFrame, actFrame.l, actFrame.t, actFrame.r, actFrame.b, keepFrames)
				actFrame := nil 
			end 
			Update(actView, keepFrames)
			actView := nil 
		end 
	end TrapCleanup
	
	proc Init
		var 
			h: NotifyHook
	begin 
		new(h)
		Dialog.SetNotifyHook(h)
		domainGuard := 0
		ClearQueue
		Kernel.InstallTrapChecker(TrapCleanup)
	end Init

begin
	Init
end Views
